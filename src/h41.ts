import * as cheerio from "cheerio";
import { promises as fs } from "fs";
import { join } from "path";
import { discoverRecentReleaseDates } from "./h41-release-discovery.js";

export type H41Card = {
  key: string;              // â“, â“‘ ...
  title: string;            // í‘œì‹œëª…
  fedLabel: string;         // H.4.1 ì›ë¬¸ ë¼ë²¨(ë§¤ì¹­ ê¸°ì¤€)
  balance_musd: number;     // ì”ì•¡ (Millions of USD)
  change_musd: number;      // ì „ì£¼ ëŒ€ë¹„ ë³€í™” (Millions of USD)
  balance_okeusd: number;   // ì”ì•¡ (ì–µ ë‹¬ëŸ¬) = musd / 100
  change_okeusd: number;    // ë³€í™” (ì–µ ë‹¬ëŸ¬)
  liquidityTag: "í¡ìˆ˜(ì•½ì¬)" | "ê³µê¸‰(í•´ì—´)" | "QT/ìì‚°" | "ìƒíƒœ";
  concept: string;          // ê³„ì • ê°œë… ì„¤ëª…
  interpretation: string;  // í•´ì„ (ì˜ë¯¸ì™€ ì „ê°œë§Œ)
  dataDate: string;         // ë°ì´í„° ë‚ ì§œ (Week ended)
  qtQeSignal?: "QT" | "QE" | "ì¤‘ë¦½"; // QT/QE ì‹ í˜¸
};

export type WarningLevel = 0 | 1 | 2 | 3;

export type TeamSignal = {
  blueTeam: string;
  whiteTeam: string;
  summary: string;
};

export type HistoricalData = {
  date: string;  // ISO date string
  weekEnded: string;
  cards: Array<{
    fedLabel: string;
    balance_musd: number;
    change_musd: number;
  }>;
};

export type H41Report = {
  releaseDateText: string;   // "December 18, 2025"
  asOfWeekEndedText: string; // "Dec 17, 2025"
  sourceUrl: string;
  cards: H41Card[];
  updatedAtISO: string;
  // ìƒˆë¡œ ì¶”ê°€ëœ í•„ë“œë“¤
  warningLevel: WarningLevel;
  assetGuidance: string;
  teamSignal: TeamSignal;
  weeklySummary: string;
  coreCards: H41Card[]; // í•µì‹¬ 6ê°œë§Œ
};

const SOURCE_URL = "https://www.federalreserve.gov/releases/h41/current/";
const ARCHIVE_BASE_URL = "https://www.federalreserve.gov/releases/h41/";
const DATA_DIR = join(process.cwd(), "data");
const HISTORICAL_DATA_FILE = join(DATA_DIR, "historical.json");

/**
 * H.4.1 current pageëŠ” í…ìŠ¤íŠ¸ê°€ ê¸¸ê²Œ í’€ë¦° êµ¬ì¡°ë¼,
 * "ë¼ë²¨ í…ìŠ¤íŠ¸"ë¥¼ ì°¾ê³  ê·¸ ë‹¤ìŒì— ë“±ì¥í•˜ëŠ” ìˆ«ì 2ê°œ(week ended, change from prev week)ë¥¼ ì¡ëŠ” ë°©ì‹ì´ ê°€ì¥ íŠ¼íŠ¼í•©ë‹ˆë‹¤.
 */
function parseNumberFromText(t: string): number | null {
  // "  833,093" ê°™ì€ í˜•ì‹ ì²˜ë¦¬
  const cleaned = t.replace(/\u00a0/g, " ").trim();
  if (!cleaned) return null;

  // ë¶€í˜¸(+/-) ë³´ì¡´, ì½¤ë§ˆ ì œê±°
  const m = cleaned.match(/^([+-])?\s*([\d,]+)$/);
  if (!m) return null;
  const sign = m[1] === "-" ? -1 : 1;
  const n = Number(m[2].replace(/,/g, ""));
  if (!Number.isFinite(n)) return null;
  return sign * n;
}

function toOkEusd(musd: number): number {
  // Millions of USD -> ì–µ ë‹¬ëŸ¬(100M)
  return musd / 100;
}

/**
 * ë‚ ì§œë¥¼ yyyy-mm-dd í˜•ì‹ìœ¼ë¡œ ë³€í™˜
 * "December 18, 2025" -> "2025-12-18"
 * "Dec 17, 2025" -> "2025-12-17"
 */
function formatDateToYYYYMMDD(dateStr: string): string {
  try {
    // "December 18, 2025" ë˜ëŠ” "Dec 17, 2025" í˜•ì‹ íŒŒì‹±
    const date = new Date(dateStr);
    if (isNaN(date.getTime())) {
      return dateStr; // íŒŒì‹± ì‹¤íŒ¨ ì‹œ ì›ë³¸ ë°˜í™˜
    }
    const year = date.getFullYear();
    const month = String(date.getMonth() + 1).padStart(2, '0');
    const day = String(date.getDate()).padStart(2, '0');
    return `${year}-${month}-${day}`;
  } catch {
    return dateStr; // ì—ëŸ¬ ì‹œ ì›ë³¸ ë°˜í™˜
  }
}

function fmtOk(v: number): string {
  const sign = v > 0 ? "+" : v < 0 ? "-" : "";
  const abs = Math.abs(v);
  // ì†Œìˆ˜ 1ìë¦¬ ì •ë„ê°€ ì½ê¸° ì¢‹ìŒ(ì›í•˜ë©´ 0ìë¦¬ë¡œ ë°”ê¿”ë„ ë¨)
  return `${sign}$${abs.toFixed(1)}ì–µ`;
}

/**
 * ê³„ì • ê°œë… ì„¤ëª… ìƒì„±
 */
export function getConcept(fedLabel: string, liquidityTag: H41Card["liquidityTag"]): string {
  if (fedLabel.includes("Treasury") && fedLabel.includes("General Account")) {
    return "ì¬ë¬´ë¶€ ì¼ë°˜ê³„ì •(TGA)ì€ ì •ë¶€ê°€ ì§•ìˆ˜í•œ ì„¸ê¸ˆê³¼ êµ­ì±„ ë°œí–‰ ìê¸ˆì„ ë³´ê´€í•˜ëŠ” ê³„ì •ì…ë‹ˆë‹¤. TGAê°€ ì¦ê°€í•˜ë©´ ì •ë¶€ê°€ ì‹œì¤‘ì—ì„œ ìê¸ˆì„ í¡ìˆ˜í•˜ëŠ” ê²ƒì´ê³ , ê°ì†Œí•˜ë©´ ì •ë¶€ê°€ ì§€ì¶œí•˜ì—¬ ì‹œì¤‘ì— ìê¸ˆì„ ê³µê¸‰í•˜ëŠ” ê²ƒì…ë‹ˆë‹¤.";
  }
  if (fedLabel.includes("Reverse repurchase")) {
    return "ì—­ë¦¬í¬(RRP)ëŠ” ê¸ˆìœµê¸°ê´€ì´ ì—°ì¤€ì— ë‹¨ê¸° ìê¸ˆì„ ì˜ˆì¹˜í•˜ëŠ” ìˆ˜ë‹¨ì…ë‹ˆë‹¤. RRP ì¦ê°€ëŠ” ì‹œì¤‘ ìœ ë™ì„±ì´ ì—°ì¤€ìœ¼ë¡œ í¡ìˆ˜ë˜ê³  ìˆìŒì„ ì˜ë¯¸í•˜ë©°, ê°ì†ŒëŠ” ì‹œì¥ìœ¼ë¡œ ìœ ë™ì„±ì´ ëŒì•„ê°€ê³  ìˆìŒì„ ì˜ë¯¸í•©ë‹ˆë‹¤.";
  }
  if (fedLabel.includes("Repurchase agreements") && !fedLabel.includes("Reverse")) {
    return "ë¦¬í¬(Repo)ëŠ” ì—°ì¤€ì´ ê¸ˆìœµê¸°ê´€ì— ë‹¨ê¸° ìê¸ˆì„ ê³µê¸‰í•˜ëŠ” ìˆ˜ë‹¨ì…ë‹ˆë‹¤. Repo ì¦ê°€ëŠ” ì—°ì¤€ì˜ ìœ ë™ì„± ê³µê¸‰ í™•ëŒ€ë¥¼ ì˜ë¯¸í•˜ë©°, ê°ì†ŒëŠ” ê³µê¸‰ ì¶•ì†Œë¥¼ ì˜ë¯¸í•©ë‹ˆë‹¤.";
  }
  if (fedLabel.includes("Primary credit")) {
    return "Primary Creditì€ ì€í–‰ë“¤ì´ ì—°ì¤€ìœ¼ë¡œë¶€í„° ì§ì ‘ ì°¨ì…í•˜ëŠ” ìœµìì…ë‹ˆë‹¤. ì´ëŠ” ê¸ˆìœµ ì‹œìŠ¤í…œì˜ ìœ ë™ì„± ê³µê¸‰ ìˆ˜ë‹¨ ì¤‘ í•˜ë‚˜ë¡œ, ì¦ê°€ëŠ” ìœ ë™ì„± ê³µê¸‰ í™•ëŒ€ë¥¼ ì˜ë¯¸í•©ë‹ˆë‹¤.";
  }
  if (fedLabel.includes("Securities held outright")) {
    return "ë³´ìœ ì¦ê¶Œ ì´ê³„ëŠ” ì—°ì¤€ì´ ë³´ìœ í•œ êµ­ì±„ì™€ MBSì˜ ì´ì•¡ì…ë‹ˆë‹¤. ì´ëŠ” ì—°ì¤€ì˜ ìì‚° ê·œëª¨ë¥¼ ë‚˜íƒ€ë‚´ë©°, ê°ì†ŒëŠ” ì–‘ì ê¸´ì¶•(QT), ì¦ê°€ëŠ” ì–‘ì ì™„í™”(QE)ë¥¼ ì˜ë¯¸í•©ë‹ˆë‹¤.";
  }
  if (fedLabel.includes("Reserve balances")) {
    return "ì§€ì¤€ê¸ˆ(Reserve balances)ì€ ì€í–‰ë“¤ì´ ì—°ì¤€ì— ì˜ˆì¹˜í•œ ì¤€ë¹„ê¸ˆì…ë‹ˆë‹¤. ì´ëŠ” ì€í–‰ ì‹œìŠ¤í…œì˜ ìœ ë™ì„± ì¿ ì…˜ì„ ë‚˜íƒ€ë‚´ë©°, ì¦ê°€ëŠ” ëŒ€ì¶œ ì—¬ë ¥ í™•ëŒ€, ê°ì†ŒëŠ” ëŒ€ì¶œ ì—¬ë ¥ ì¶•ì†Œë¥¼ ì˜ë¯¸í•©ë‹ˆë‹¤.";
  }
  return "";
}

/**
 * QT/QE ì‹ í˜¸ íŒë‹¨
 */
function getQtQeSignal(
  fedLabel: string,
  change_musd: number
): "QT" | "QE" | "ì¤‘ë¦½" {
  if (fedLabel.includes("Securities held outright")) {
    // ë³´ìœ ì¦ê¶Œ ê°ì†Œ = QT, ì¦ê°€ = QE
    if (change_musd < -20000) return "QT"; // 200ì–µ ì´ìƒ ê°ì†Œ
    if (change_musd > 20000) return "QE"; // 200ì–µ ì´ìƒ ì¦ê°€
    return "ì¤‘ë¦½";
  }
  return "ì¤‘ë¦½";
}

/**
 * ë™ì  í•´ì„ì„ ìœ„í•œ ì£¼ê°„ ì»¨í…ìŠ¤íŠ¸ ìƒì„± (í–¥í›„ í™•ì¥ ê°€ëŠ¥)
 * ì‹¤ì œ ê²½ì œ ë‰´ìŠ¤, ê¸ˆë¦¬, ì£¼ê°€ ë“±ì„ ë¶„ì„í•˜ì—¬ ë§¤ì£¼ ë‹¤ë¥¸ í•´ì„ ì œê³µ
 */
async function getWeeklyContext(): Promise<{
  weekNumber: number;
  month: number;
  context: string;
}> {
  const now = new Date();
  const weekNumber = Math.ceil(now.getDate() / 7);
  const month = now.getMonth() + 1;
  
  // í–¥í›„: ê²½ì œ ë‰´ìŠ¤, ê¸ˆë¦¬ ë°ì´í„°, ì£¼ê°€ ì§€ìˆ˜ ë“±ì„ ê°€ì ¸ì™€ì„œ ì»¨í…ìŠ¤íŠ¸ ìƒì„±
  // í˜„ì¬ëŠ” ê¸°ë³¸ êµ¬ì¡°ë§Œ ì œê³µ
  const contexts = [
    "ì´ë²ˆ ì£¼ëŠ” ì—°ì¤€ì˜ í†µí™”ì •ì±… ë°©í–¥ì„±ì— ëŒ€í•œ ì‹œì¥ì˜ ê´€ì‹¬ì´ ë†’ì•„ì§„ ê°€ìš´ë°",
    "ìµœê·¼ ê¸ˆë¦¬ ë³€ë™ì„±ê³¼ ìê¸ˆ ì‹œì¥ì˜ ìŠ¤íŠ¸ë ˆìŠ¤ ì§€í‘œë¥¼ ê³ ë ¤í•  ë•Œ",
    "ì£¼ìš” ê²½ì œ ì§€í‘œì™€ ì¸í”Œë ˆì´ì…˜ ë°ì´í„°ë¥¼ ì¢…í•©í•˜ë©´",
    "ê¸ˆìœµ ì‹œì¥ì˜ ë¦¬ìŠ¤í¬ ì„ í˜¸ë„ ë³€í™”ì™€ í•¨ê»˜",
    "ê¸€ë¡œë²Œ ìœ ë™ì„± í™˜ê²½ê³¼ ë‹¬ëŸ¬ ê°•ì„¸ë¥¼ ê³ ë ¤í•˜ë©´"
  ];
  
  const context = contexts[weekNumber % contexts.length];
  
  return { weekNumber, month, context };
}

/**
 * í•´ì„ ìƒì„± (ì˜ë¯¸ì™€ ì „ê°œë§Œ, ìˆ˜ì¹˜ëŠ” ì œì™¸)
 * ë§¤ì£¼ ë‹¤ë¥¸ ì»¨í…ìŠ¤íŠ¸ë¥¼ ë°˜ì˜í•˜ì—¬ ë™ì  í•´ì„ ì œê³µ
 */
async function interpret(rule: {
  liquidityTag: H41Card["liquidityTag"];
  title: string;
  fedLabel: string;
  change_musd: number;
  balance_musd: number;
}, weeklyContext: { weekNumber: number; month: number; context: string }): Promise<string> {
  const ch = rule.change_musd;
  const absCh = Math.abs(ch);
  const absChOk = absCh / 100; // ì–µ ë‹¬ëŸ¬ ë‹¨ìœ„
  
  // ë¨¸ë¦¿ë§ê³¼ ë³¸ë¬¸ì„ ë¶„ë¦¬í•˜ì—¬ ë°˜í™˜ (ë‚´ìš©ì´ ì˜ë¦¬ì§€ ì•Šë„ë¡ ì „ì²´ í‘œì‹œ)
  const formatInterpretation = (headline: string, body: string, context?: string): string => {
    // ì»¨í…ìŠ¤íŠ¸ê°€ ìˆìœ¼ë©´ ì•ì— ì¶”ê°€
    let fullBody = body;
    if (context) {
      fullBody = `${context} ${body}`;
    }
    
    // ë¨¸ë¦¿ë§ë§Œ ë³¼ë“œ ì²˜ë¦¬í•˜ê³ , ë³¸ë¬¸ì€ ê·¸ëŒ€ë¡œ í‘œì‹œ (í‚¤ì›Œë“œ ê°•ì¡° ì œê±°, ** ê¸°í˜¸ ì œê±°)
    return `${headline}\n${fullBody}`;
  };

  // ë³€í™”ê°€ 0ì´ë©´
  if (ch === 0) {
    switch (rule.liquidityTag) {
      case "í¡ìˆ˜(ì•½ì¬)":
        return formatInterpretation(
          "í˜„ì¬ ìƒíƒœ ìœ ì§€ ì¤‘",
          "ì´ ì§€í‘œê°€ ë³€ë™ì´ ì—†ë‹¤ëŠ” ê±´, ì—°ì¤€ê³¼ ì¬ë¬´ë¶€ê°€ ì˜ë„ì ìœ¼ë¡œ ì´ ìˆ˜ì¤€ì„ ìœ ì§€í•˜ê³  ìˆë‹¤ëŠ” ì‹ í˜¸ì˜ˆìš”. ê±°ëŒ€ ìë³¸ê°€ë“¤ì€ ì´ëŸ° 'ì •ì§€ ìƒíƒœ'ë¥¼ ê¸°íšŒë¡œ ë´…ë‹ˆë‹¤. ì‹œì¥ì´ ì˜ˆì¸¡ ê°€ëŠ¥í•œ êµ¬ê°„ì— ìˆë‹¤ëŠ” ëœ»ì´ë‹ˆê¹Œìš”. ë¸”ë™ë¡ì´ë‚˜ ë±…ê°€ë“œ ê°™ì€ ê¸°ê´€ë“¤ì€ ì´ëŸ° ë•Œ í¬ì§€ì…˜ì„ ì¡°ì •í•˜ê±°ë‚˜ ìƒˆë¡œìš´ ì „ëµì„ ì¤€ë¹„í•©ë‹ˆë‹¤."
        );
      case "ê³µê¸‰(í•´ì—´)":
        return formatInterpretation(
          "ìœ ë™ì„± ê³µê¸‰ ì•ˆì •",
          "ì—°ì¤€ì´ ì‹œì¥ì— ìê¸ˆì„ ê³µê¸‰í•˜ëŠ” ì†ë„ê°€ ì¼ì •í•˜ê²Œ ìœ ì§€ë˜ê³  ìˆì–´ìš”. ì´ê±´ ì—°ì¤€ì´ 'ì§€ê¸ˆ ì´ ì •ë„ë©´ ì¶©ë¶„í•˜ë‹¤'ê³  íŒë‹¨í•˜ê³  ìˆë‹¤ëŠ” ì˜ë¯¸ì…ë‹ˆë‹¤. ë¯¸êµ­ì˜ ê¸ˆìœµ í—¤ê²Œëª¨ë‹ˆ ê´€ì ì—ì„œ ë³´ë©´, ê¸€ë¡œë²Œ ë‹¬ëŸ¬ ìœ ë™ì„±ì„ ì ì ˆíˆ ê´€ë¦¬í•˜ë©´ì„œë„ ì‹œì¥ ì•ˆì •ì„±ì„ ìœ ì§€í•˜ë ¤ëŠ” ì˜ë„ë¡œ ì½í™ë‹ˆë‹¤."
        );
      case "QT/ìì‚°":
        return formatInterpretation(
          "QT ì†ë„ ì¼ì‹œ ì •ì§€",
          "ì—°ì¤€ì˜ ìì‚° ì¶•ì†Œê°€ ì ì‹œ ë©ˆì¶˜ ìƒíƒœë„¤ìš”. ì´ê±´ ë‹¨ìˆœíˆ 'QT ì¤‘ë‹¨'ì´ ì•„ë‹ˆë¼, ì—°ì¤€ì´ ì‹œì¥ ë°˜ì‘ì„ ì§€ì¼œë³´ëŠ” ì¤‘ì´ë¼ëŠ” ì‹ í˜¸ì…ë‹ˆë‹¤. ê±°ëŒ€ ìë³¸ê°€ë“¤ì€ ì´ëŸ° 'í˜¸í¡ ì¡°ì ˆ' ì‹œì ì„ ë§¤ìš° ì£¼ì˜ ê¹Šê²Œ ë´…ë‹ˆë‹¤. ë‹¤ìŒ ì›€ì§ì„ì´ ë” ì¤‘ìš”í•´ì§ˆ ê±°ì˜ˆìš”."
        );
      case "ìƒíƒœ":
        if (rule.fedLabel.includes("Reserve balances")) {
          return formatInterpretation(
            "ì€í–‰ ì‹œìŠ¤í…œ ì¿ ì…˜ ìœ ì§€",
            "ì€í–‰ë“¤ì´ ì—°ì¤€ì— ì˜ˆì¹˜í•œ ì¤€ë¹„ê¸ˆì´ ì•ˆì •ì ì´ë¼ëŠ” ê±´, ê¸ˆìœµ ì‹œìŠ¤í…œì´ ì—¬ìœ  ìˆëŠ” ìƒíƒœë¼ëŠ” ëœ»ì…ë‹ˆë‹¤. ì´ê±´ ë¯¸êµ­ì´ ê¸€ë¡œë²Œ ê¸ˆìœµ ì‹œìŠ¤í…œì„ í†µì œí•  ìˆ˜ ìˆëŠ” ì—¬ë ¥ì´ ì¶©ë¶„í•˜ë‹¤ëŠ” ì‹ í˜¸ì˜ˆìš”. ê±°ëŒ€ ìë³¸ê°€ë“¤ì€ ì´ëŸ° ì•ˆì •ì„±ì´ ì–¸ì œê¹Œì§€ ì§€ì†ë ì§€ê°€ ê´€ì‹¬ì‚¬ì…ë‹ˆë‹¤."
          );
        }
        return formatInterpretation(
          "í˜„ì¬ ìˆ˜ì¤€ ìœ ì§€",
          "ì´ ì§€í‘œê°€ ë³€ë™ì´ ì—†ë‹¤ëŠ” ê±´, ì‹œìŠ¤í…œì´ ì˜ë„í•œ ëŒ€ë¡œ ì‘ë™í•˜ê³  ìˆë‹¤ëŠ” ì˜ë¯¸ì…ë‹ˆë‹¤. ê±°ì‹œì ìœ¼ë¡œ ë³´ë©´ í° ë³€í™”ê°€ ì—†ëŠ” ê²Œ ì˜¤íˆë ¤ ì¤‘ìš”í•œ ì‹ í˜¸ì¼ ìˆ˜ ìˆì–´ìš”."
        );
    }
  }

  switch (rule.liquidityTag) {
    case "í¡ìˆ˜(ì•½ì¬)":
      if (rule.fedLabel.includes("Treasury")) {
        // TGA
        if (ch > 0) {
          return formatInterpretation(
            "ì •ë¶€ ìê¸ˆ í¡ìˆ˜ë¡œ ì‹œì¥ ìœ ë™ì„± ì••ë°•",
            "ì¬ë¬´ë¶€ê°€ ì„¸ê¸ˆ ì§•ìˆ˜ë‚˜ êµ­ì±„ ë°œí–‰ ìê¸ˆì„ ì˜ˆì¹˜í•˜ë©´ì„œ ì‹œì¤‘ ìœ ë™ì„±ì´ ì •ë¶€ ê³„ì •ìœ¼ë¡œ í¡ìˆ˜ë˜ê³  ìˆìŠµë‹ˆë‹¤. ì´ëŠ” ë‹¨ê¸°ì ìœ¼ë¡œ ìê¸ˆ ì‹œì¥ì˜ ê¸ˆë¦¬ ìƒìŠ¹ ì••ë ¥ê³¼ ìì‚° ê°€ê²© ì¡°ì • ì••ë ¥ìœ¼ë¡œ ì‘ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.",
            weeklyContext.context
          );
        } else {
          return formatInterpretation(
            "ì •ë¶€ ì§€ì¶œ í™•ëŒ€ë¡œ ì‹œì¥ ìœ ë™ì„± ê³µê¸‰",
            "ì¬ë¬´ë¶€ê°€ ì˜ˆì¹˜ëœ ìê¸ˆì„ ì§€ì¶œí•˜ë©´ì„œ ì‹œì¤‘ ìœ ë™ì„±ì´ ê³µê¸‰ë˜ê³  ìˆìŠµë‹ˆë‹¤. ì´ëŠ” ìê¸ˆ ì‹œì¥ì˜ ê¸ˆë¦¬ í•˜ë½ ì••ë ¥ê³¼ ìì‚° ê°€ê²© ìƒìŠ¹ ìš”ì¸ìœ¼ë¡œ ì‘ìš©í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.",
            weeklyContext.context
          );
        }
      } else if (rule.fedLabel.includes("Reverse repurchase")) {
        // RRP
        if (ch > 0) {
          return formatInterpretation(
            "í° ì†ë“¤ì´ ì—°ì¤€ì— ëˆì„ ë§¡ê¸°ê³  ìˆì–´ìš”",
            "RRPê°€ ëŠ˜ì–´ë‚œë‹¤ëŠ” ê±´, ë±…ê°€ë“œë‚˜ ë¸”ë™ë¡ ê°™ì€ ê±°ëŒ€ ê¸ˆìœµê¸°ê´€ë“¤ì´ 'ì•ˆì „í•œ ê³³'ì— ëˆì„ ë§¡ê¸°ê³  ìˆë‹¤ëŠ” ì‹ í˜¸ì…ë‹ˆë‹¤. ì´ê²Œ ì™œ ì¤‘ìš”í•œê°€? ì´ë“¤ì€ ì‹œì¥ì—ì„œ ê°€ì¥ ì˜ˆë¦¬í•œ ëˆˆì„ ê°€ì§„ ìë³¸ê°€ë“¤ì´ê±°ë“ ìš”. RRPì— ëˆì„ ë§¡ê¸´ë‹¤ëŠ” ê±´, ì§€ê¸ˆ ì‹œì¥ì— ë§¤ë ¥ì ì¸ íˆ¬ìì²˜ê°€ ì—†ë‹¤ê³  íŒë‹¨í•˜ê±°ë‚˜, ê³§ ë³€ë™ì„±ì´ ì»¤ì§ˆ ê±°ë¼ê³  ì˜ˆìƒí•œë‹¤ëŠ” ëœ»ì…ë‹ˆë‹¤. ë¯¸êµ­ì˜ ê´€ì ì—ì„œ ë³´ë©´, ì´ê±´ ë‹¬ëŸ¬ê°€ ì—¬ì „íˆ 'ìµœê³ ì˜ ì•ˆì „ìì‚°'ìœ¼ë¡œ ì¸ì •ë°›ê³  ìˆë‹¤ëŠ” ì¦ê±°ì˜ˆìš”. ê¸€ë¡œë²Œ ìë³¸ì´ ë¯¸êµ­ìœ¼ë¡œ ëª°ë¦¬ëŠ” êµ¬ì¡°ê°€ ìœ ì§€ë˜ê³  ìˆë‹¤ëŠ” ê±°ì£ .",
            weeklyContext.context
          );
        } else {
          return formatInterpretation(
            "í° ì†ë“¤ì´ ì—°ì¤€ì—ì„œ ëˆì„ ë¹¼ë‚´ê³  ìˆì–´ìš”",
            "RRPì—ì„œ ëˆì´ ë¹ ì ¸ë‚˜ê°„ë‹¤ëŠ” ê±´, ê±°ëŒ€ ìë³¸ê°€ë“¤ì´ 'ì´ì œ ì›€ì§ì¼ ë•Œë‹¤'ê³  íŒë‹¨í–ˆë‹¤ëŠ” ì‹ í˜¸ì…ë‹ˆë‹¤. ì´ë“¤ì€ ì—°ì¤€ì— ëˆì„ ë§¡ê²¨ë‘ëŠ” ê²ƒë³´ë‹¤ ì‹œì¥ì—ì„œ ë” ë‚˜ì€ ê¸°íšŒë¥¼ ì°¾ê³  ìˆë‹¤ëŠ” ëœ»ì´ì—ìš”. ì´ëŸ° ì›€ì§ì„ì€ ë³´í†µ ìì‚° ê°€ê²© ìƒìŠ¹ì˜ ì „ì¡°ê°€ ë©ë‹ˆë‹¤. ë±…ê°€ë“œë‚˜ ë¸”ë™ë¡ ê°™ì€ ê¸°ê´€ë“¤ì´ í¬ì§€ì…˜ì„ ëŠ˜ë¦¬ê¸° ì‹œì‘í–ˆë‹¤ëŠ” ì˜ë¯¸ë‹ˆê¹Œìš”. ë¯¸êµ­ì˜ í—¤ê²Œëª¨ë‹ˆ ê´€ì ì—ì„œ ë³´ë©´, ì´ê±´ ê¸€ë¡œë²Œ ìë³¸ì´ ë‹¤ì‹œ ë¯¸êµ­ ìì‚°ìœ¼ë¡œ ëª°ë¦¬ê¸° ì‹œì‘í•œë‹¤ëŠ” ì‹ í˜¸ì¼ ìˆ˜ ìˆì–´ìš”.",
            weeklyContext.context
          );
        }
      } else {
        if (ch > 0) {
          return formatInterpretation(
            "ì‹œì¥ì—ì„œ ëˆì´ ë¹ ì ¸ë‚˜ê°€ê³  ìˆì–´ìš”",
            "ì´ ì§€í‘œê°€ ì»¤ì§„ë‹¤ëŠ” ê±´, ì‹œì¥ì— ëŒì•„ë‹¤ë‹ˆëŠ” ìœ ë™ì„±ì´ ì¤„ì–´ë“ ë‹¤ëŠ” ëœ»ì…ë‹ˆë‹¤. ê±°ëŒ€ ìë³¸ê°€ë“¤ì˜ ê´€ì ì—ì„œ ë³´ë©´, ì´ëŸ° ì‹œì ì€ ë°©ì–´ì ìœ¼ë¡œ í¬ì§€ì…˜ì„ ì¡°ì •í•´ì•¼ í•  ë•Œì˜ˆìš”. ë¯¸êµ­ì´ ê¸€ë¡œë²Œ ë‹¬ëŸ¬ ìœ ë™ì„±ì„ ì¡°ì ˆí•˜ë©´ì„œ ìì‚° ê°€ê²©ì„ í†µì œí•˜ë ¤ëŠ” ì˜ë„ë¡œ ì½í™ë‹ˆë‹¤. ë±…ê°€ë“œë‚˜ ë¸”ë™ë¡ ê°™ì€ ê¸°ê´€ë“¤ì€ ì´ëŸ° í™˜ê²½ì—ì„œ ê³ ë³€ë™ì„± ìì‚°ì˜ ë¹„ì¤‘ì„ ì¤„ì´ê³ , í˜„ê¸ˆì´ë‚˜ ë°©ì–´ì  ìì‚°ìœ¼ë¡œ ì „í™˜í•©ë‹ˆë‹¤."
          );
        } else {
          return formatInterpretation(
            "ì‹œì¥ì— ëˆì´ ë‹¤ì‹œ ëŒì•„ì˜¤ê³  ìˆì–´ìš”",
            "ì´ ì§€í‘œê°€ ì¤„ì–´ë“ ë‹¤ëŠ” ê±´, ìœ ë™ì„± ì••ë°•ì´ ì™„í™”ë˜ê³  ìˆë‹¤ëŠ” ì‹ í˜¸ì…ë‹ˆë‹¤. ê±°ëŒ€ ìë³¸ê°€ë“¤ì€ ì´ëŸ° ì‹œì ì„ ê¸°íšŒë¡œ ë´…ë‹ˆë‹¤. ìœ ë™ì„±ì´ í’€ë¦¬ë©´ì„œ ìì‚° ê°€ê²©ì´ ì˜¤ë¥¼ ì—¬ì§€ê°€ ìƒê¸°ë‹ˆê¹Œìš”. í•˜ì§€ë§Œ ì—¬ê¸°ì„œ ì¤‘ìš”í•œ ê±´, ì´ê²Œ ì¼ì‹œì ì¸ì§€ ì§€ì†ì ì¸ì§€ íŒë‹¨í•˜ëŠ” ê±°ì˜ˆìš”. ë¯¸êµ­ì˜ ì •ì±… ì˜ë„ë¥¼ ì •í™•íˆ ì½ì–´ì•¼ í•©ë‹ˆë‹¤."
          );
        }
      }
    case "ê³µê¸‰(í•´ì—´)":
      if (rule.fedLabel.includes("Repurchase agreements")) {
        // Repo
        if (ch > 0) {
          return formatInterpretation(
            "ì—°ì¤€ì´ ì‹œì¥ì— ëˆì„ í‘¸ëŠ” ì†ë„ë¥¼ ë†’ì´ê³  ìˆì–´ìš”",
            "Repoê°€ ëŠ˜ì–´ë‚œë‹¤ëŠ” ê±´, ì—°ì¤€ì´ ê¸ˆìœµê¸°ê´€ë“¤ì—ê²Œ ë‹¨ê¸° ìê¸ˆì„ ë” ë§ì´ ë¹Œë ¤ì£¼ê³  ìˆë‹¤ëŠ” ëœ»ì…ë‹ˆë‹¤. ì´ê²Œ ë‹¨ìˆœíˆ 'ëˆì„ í’€ì–´ì¤€ë‹¤'ëŠ” ê²Œ ì•„ë‹ˆë¼, ì—°ì¤€ì´ ì‹œì¥ì˜ ìœ ë™ì„± ë¶€ì¡±ì„ ê°ì§€í•˜ê³  ì ê·¹ì ìœ¼ë¡œ ê°œì…í•˜ê³  ìˆë‹¤ëŠ” ì‹ í˜¸ì˜ˆìš”. ê±°ëŒ€ ìë³¸ê°€ë“¤ì€ ì´ëŸ° ì›€ì§ì„ì„ ë§¤ìš° ì£¼ì˜ ê¹Šê²Œ ë´…ë‹ˆë‹¤. ì—°ì¤€ì´ 'ì‹œì¥ì„ êµ¬ì œ'í•˜ë ¤ê³  ë‚˜ì„ ë‹¤ëŠ” ê±´, ë­”ê°€ ë¬¸ì œê°€ ìˆë‹¤ëŠ” ëœ»ì¼ ìˆ˜ë„ ìˆê±°ë“ ìš”. í•˜ì§€ë§Œ ë™ì‹œì— ìœ ë™ì„±ì´ í’€ë¦¬ë©´ì„œ ìì‚° ê°€ê²©ì´ ì˜¤ë¥¼ ê¸°íšŒê°€ ìƒê¸°ê¸°ë„ í•©ë‹ˆë‹¤. ë¯¸êµ­ì˜ í—¤ê²Œëª¨ë‹ˆ ê´€ì ì—ì„œ ë³´ë©´, ì´ê±´ ê¸€ë¡œë²Œ ê¸ˆìœµ ì‹œìŠ¤í…œì„ ì•ˆì •ì‹œí‚¤ë©´ì„œë„ ë‹¬ëŸ¬ì˜ ì§€ë°°ë ¥ì„ ìœ ì§€í•˜ëŠ” ì „ëµì˜ ì¼ë¶€ì…ë‹ˆë‹¤.",
            weeklyContext.context
          );
        } else {
          return formatInterpretation(
            "ì—°ì¤€ì´ ëˆ í’€ê¸°ë¥¼ ì¤„ì´ê³  ìˆì–´ìš”",
            "Repoê°€ ì¤„ì–´ë“ ë‹¤ëŠ” ê±´, ì—°ì¤€ì´ ì‹œì¥ ê°œì…ì„ ì¶•ì†Œí•˜ê³  ìˆë‹¤ëŠ” ì‹ í˜¸ì…ë‹ˆë‹¤. ì´ê²Œ ì™œ ì¤‘ìš”í•œê°€? ì—°ì¤€ì´ 'ì´ì œ ì‹œì¥ì´ ìŠ¤ìŠ¤ë¡œ ëŒì•„ê°ˆ ìˆ˜ ìˆë‹¤'ê³  íŒë‹¨í–ˆë‹¤ëŠ” ëœ»ì´ê±°ë“ ìš”. ê±°ëŒ€ ìë³¸ê°€ë“¤ì€ ì´ëŸ° ì‹œì ì„ ë§¤ìš° ì˜ˆë¦¬í•˜ê²Œ ë´…ë‹ˆë‹¤. ì—°ì¤€ì˜ ì§€ì›ì´ ì¤„ì–´ë“¤ë©´ ì‹œì¥ì´ ë” ì·¨ì•½í•´ì§ˆ ìˆ˜ ìˆìœ¼ë‹ˆê¹Œìš”. ë±…ê°€ë“œë‚˜ ë¸”ë™ë¡ ê°™ì€ ê¸°ê´€ë“¤ì€ ì´ëŸ° í™˜ê²½ì—ì„œ í¬ì§€ì…˜ì„ ë” ë°©ì–´ì ìœ¼ë¡œ ì¡°ì •í•©ë‹ˆë‹¤.",
            weeklyContext.context
          );
        }
      } else if (rule.fedLabel.includes("Primary credit")) {
        if (ch > 0) {
          return formatInterpretation(
            "ì€í–‰ë“¤ì´ ì—°ì¤€ì— SOS ì‹ í˜¸ë¥¼ ë³´ë‚´ê³  ìˆì–´ìš”",
            "Primary Creditì´ ëŠ˜ì–´ë‚œë‹¤ëŠ” ê±´, ì€í–‰ë“¤ì´ ì‹œì¥ì—ì„œ ëˆì„ ëª» ë¹Œë ¤ì„œ ì—°ì¤€ì— ì§ì ‘ ì™€ì„œ ë¹Œë¦¬ê³  ìˆë‹¤ëŠ” ëœ»ì…ë‹ˆë‹¤. ì´ê±´ ê¸ˆìœµ ì‹œìŠ¤í…œì— ìŠ¤íŠ¸ë ˆìŠ¤ê°€ ìˆë‹¤ëŠ” ì‹ í˜¸ì˜ˆìš”. ê±°ëŒ€ ìë³¸ê°€ë“¤ì€ ì´ëŸ° ì§€í‘œë¥¼ ë§¤ìš° ê²½ê³„í•©ë‹ˆë‹¤. ì€í–‰ë“¤ì´ ëˆì„ ëª» ë¹Œë¦°ë‹¤ëŠ” ê±´, ì‹ ìš© ê²½ìƒ‰ì´ ì‹œì‘ë  ìˆ˜ ìˆë‹¤ëŠ” ëœ»ì´ê±°ë“ ìš”. ë¯¸êµ­ì˜ ê´€ì ì—ì„œ ë³´ë©´, ì´ê±´ ê¸ˆìœµ ì‹œìŠ¤í…œì˜ ì·¨ì•½ì ì´ ë…¸ì¶œë˜ê³  ìˆë‹¤ëŠ” ì‹ í˜¸ì¼ ìˆ˜ ìˆì–´ìš”. í•˜ì§€ë§Œ ë™ì‹œì— ì—°ì¤€ì´ ê°œì…í•´ì„œ ì‹œìŠ¤í…œì„ êµ¬ì œí•˜ë ¤ëŠ” ì˜ë„ë¡œë„ ì½í™ë‹ˆë‹¤.",
            weeklyContext.context
          );
        } else {
          return formatInterpretation(
            "ì€í–‰ ì‹œìŠ¤í…œì´ ì•ˆì •ë˜ê³  ìˆì–´ìš”",
            "Primary Creditì´ ì¤„ì–´ë“ ë‹¤ëŠ” ê±´, ì€í–‰ë“¤ì´ ì‹œì¥ì—ì„œ ì •ìƒì ìœ¼ë¡œ ëˆì„ ë¹Œë¦´ ìˆ˜ ìˆë‹¤ëŠ” ëœ»ì…ë‹ˆë‹¤. ì´ê±´ ê¸ˆìœµ ì‹œìŠ¤í…œì´ ê±´ê°•í•˜ë‹¤ëŠ” ì‹ í˜¸ì˜ˆìš”. ê±°ëŒ€ ìë³¸ê°€ë“¤ì€ ì´ëŸ° ì•ˆì •ì„±ì„ ì¢‹ì•„í•©ë‹ˆë‹¤. ì‹œìŠ¤í…œì´ ì •ìƒ ì‘ë™í•˜ë©´ ìì‚° ê°€ê²©ë„ ì•ˆì •ì ìœ¼ë¡œ ì›€ì§ì¼ ê°€ëŠ¥ì„±ì´ ë†’ìœ¼ë‹ˆê¹Œìš”. ë¯¸êµ­ì˜ í—¤ê²Œëª¨ë‹ˆ ê´€ì ì—ì„œ ë³´ë©´, ì´ê±´ ê¸€ë¡œë²Œ ê¸ˆìœµ ì‹œìŠ¤í…œì´ ë‹¬ëŸ¬ ì¤‘ì‹¬ìœ¼ë¡œ ì˜ ëŒì•„ê°€ê³  ìˆë‹¤ëŠ” ì¦ê±°ì…ë‹ˆë‹¤.",
            weeklyContext.context
          );
        }
      } else {
        if (ch > 0) {
          return formatInterpretation(
            "ì‹œì¥ì— ëˆì´ ë” í’€ë¦¬ê³  ìˆì–´ìš”",
            "ì´ ì§€í‘œê°€ ì»¤ì§„ë‹¤ëŠ” ê±´, ìœ ë™ì„± ê³µê¸‰ì´ ëŠ˜ì–´ë‚˜ê³  ìˆë‹¤ëŠ” ëœ»ì…ë‹ˆë‹¤. ê±°ëŒ€ ìë³¸ê°€ë“¤ì€ ì´ëŸ° ì‹œì ì„ ê¸°íšŒë¡œ ë´…ë‹ˆë‹¤. ìœ ë™ì„±ì´ í’€ë¦¬ë©´ ìì‚° ê°€ê²©ì´ ì˜¤ë¥¼ ì—¬ì§€ê°€ ìƒê¸°ë‹ˆê¹Œìš”. í•˜ì§€ë§Œ ì—¬ê¸°ì„œ ì¤‘ìš”í•œ ê±´, ì´ê²Œ ì—°ì¤€ì˜ ì˜ë„ì ì¸ ì •ì±…ì¸ì§€, ì•„ë‹ˆë©´ ì¼ì‹œì ì¸ í˜„ìƒì¸ì§€ íŒë‹¨í•˜ëŠ” ê±°ì˜ˆìš”.",
            weeklyContext.context
          );
        } else {
          return formatInterpretation(
            "ì‹œì¥ì— í’€ë¦¬ëŠ” ëˆì´ ì¤„ì–´ë“¤ê³  ìˆì–´ìš”",
            "ì´ ì§€í‘œê°€ ì¤„ì–´ë“ ë‹¤ëŠ” ê±´, ìœ ë™ì„± ê³µê¸‰ì´ ì¶•ì†Œë˜ê³  ìˆë‹¤ëŠ” ì‹ í˜¸ì…ë‹ˆë‹¤. ê±°ëŒ€ ìë³¸ê°€ë“¤ì€ ì´ëŸ° í™˜ê²½ì—ì„œ ë” ì‹ ì¤‘í•´ì§‘ë‹ˆë‹¤. ìœ ë™ì„±ì´ ì¤„ì–´ë“¤ë©´ ìì‚° ê°€ê²©ì— ì••ë°•ì´ ê°€í•´ì§ˆ ìˆ˜ ìˆìœ¼ë‹ˆê¹Œìš”. ë¯¸êµ­ì˜ ì •ì±… ì˜ë„ë¥¼ ì •í™•íˆ ì½ì–´ì•¼ í•©ë‹ˆë‹¤.",
            weeklyContext.context
          );
        }
      }
    case "QT/ìì‚°":
      if (ch < 0) {
        const qtSpeed = absChOk > 50 ? "ê¸‰ì†" : absChOk > 20 ? "ì§€ì†" : "ì™„ë§Œ";
        return formatInterpretation(
          "ì—°ì¤€ì´ ëŒ€ì°¨ëŒ€ì¡°í‘œë¥¼ ì¤„ì´ê³  ìˆì–´ìš”",
          `ì—°ì¤€ì´ ë³´ìœ í•œ ì¦ê¶Œì„ ì¤„ì´ê³  ìˆë‹¤ëŠ” ê±´, ì–‘ì ê¸´ì¶•(QT)ì´ ${qtSpeed}í•˜ê²Œ ì§„í–‰ë˜ê³  ìˆë‹¤ëŠ” ëœ»ì…ë‹ˆë‹¤. ì´ê²Œ ì™œ ì¤‘ìš”í•œê°€? ì—°ì¤€ì´ ì‹œì¥ì—ì„œ ëˆì„ ë¹¨ì•„ë“¤ì´ê³  ìˆë‹¤ëŠ” ê±°ê±°ë“ ìš”. ê±°ëŒ€ ìë³¸ê°€ë“¤ì˜ ê´€ì ì—ì„œ ë³´ë©´, ì´ê±´ ë¯¸êµ­ì´ ê¸€ë¡œë²Œ ë‹¬ëŸ¬ ìœ ë™ì„±ì„ ì¡°ì ˆí•˜ë©´ì„œ ìì‚° ê°€ê²©ì„ í†µì œí•˜ë ¤ëŠ” ì „ëµì…ë‹ˆë‹¤. ë¸”ë™ë¡ì´ë‚˜ ë±…ê°€ë“œ ê°™ì€ ê¸°ê´€ë“¤ì€ QTê°€ ì§„í–‰ë  ë•Œ í¬íŠ¸í´ë¦¬ì˜¤ë¥¼ ë” ë°©ì–´ì ìœ¼ë¡œ ì¡°ì •í•©ë‹ˆë‹¤. ë¯¸êµ­ì˜ í—¤ê²Œëª¨ë‹ˆ ê´€ì ì—ì„œ ë³´ë©´, ì´ê±´ ë‹¬ëŸ¬ ê°•ì„¸ë¥¼ ìœ ì§€í•˜ê³  ê¸€ë¡œë²Œ ìë³¸ì„ ë¯¸êµ­ìœ¼ë¡œ ëŒì–´ë“¤ì´ëŠ” ìˆ˜ë‹¨ì´ì—ìš”. QTê°€ ë¹ ë¥¼ìˆ˜ë¡ ì‹œì¥ ë³€ë™ì„±ì´ ì»¤ì§ˆ ìˆ˜ ìˆìœ¼ë‹ˆ, ê±°ëŒ€ ìë³¸ê°€ë“¤ì€ ì´ëŸ° ì‹œì ì— í˜„ê¸ˆ ë¹„ì¤‘ì„ ëŠ˜ë¦¬ê±°ë‚˜ ë°©ì–´ì  ìì‚°ìœ¼ë¡œ ì „í™˜í•©ë‹ˆë‹¤.`,
          weeklyContext.context
        );
      } else {
        return formatInterpretation(
          "ì—°ì¤€ì´ ìì‚° ì¶•ì†Œ ì†ë„ë¥¼ ëŠ¦ì¶”ê³  ìˆì–´ìš”",
          "ì—°ì¤€ì˜ ë³´ìœ ì¦ê¶Œì´ ì¤„ì–´ë“œëŠ” ì†ë„ê°€ ë‘”í™”ë˜ê³  ìˆë‹¤ëŠ” ê±´, QT ì••ë ¥ì´ ì™„í™”ë˜ê³  ìˆë‹¤ëŠ” ì‹ í˜¸ì…ë‹ˆë‹¤. ì´ê²Œ ë‹¨ìˆœíˆ 'QT ì¤‘ë‹¨'ì´ ì•„ë‹ˆë¼, ì—°ì¤€ì´ ì‹œì¥ ë°˜ì‘ì„ ì§€ì¼œë³´ë©´ì„œ ì†ë„ë¥¼ ì¡°ì ˆí•˜ê³  ìˆë‹¤ëŠ” ëœ»ì´ì—ìš”. ê±°ëŒ€ ìë³¸ê°€ë“¤ì€ ì´ëŸ° 'í˜¸í¡ ì¡°ì ˆ' ì‹œì ì„ ë§¤ìš° ì£¼ì˜ ê¹Šê²Œ ë´…ë‹ˆë‹¤. ì—°ì¤€ì´ ë‹¤ìŒì— ì–´ë–¤ ê²°ì •ì„ ë‚´ë¦´ì§€ê°€ í•µì‹¬ì´ê±°ë“ ìš”. ë¯¸êµ­ì˜ ê´€ì ì—ì„œ ë³´ë©´, ì´ê±´ ê¸€ë¡œë²Œ ê¸ˆìœµ ì‹œìŠ¤í…œì˜ ì•ˆì •ì„±ì„ ê³ ë ¤í•˜ë©´ì„œë„ ë‹¬ëŸ¬ì˜ ì§€ë°°ë ¥ì„ ìœ ì§€í•˜ë ¤ëŠ” ê· í˜• ì „ëµì…ë‹ˆë‹¤.",
          weeklyContext.context
        );
      }
    case "ìƒíƒœ":
      if (rule.fedLabel.includes("Reserve balances")) {
        if (ch < 0) {
          return formatInterpretation(
            "ì€í–‰ ì‹œìŠ¤í…œì˜ ì•ˆì „ ì¿ ì…˜ì´ ì¤„ì–´ë“¤ê³  ìˆì–´ìš”",
            "ì§€ì¤€ê¸ˆì´ ì¤„ì–´ë“ ë‹¤ëŠ” ê±´, ì€í–‰ë“¤ì´ ì—°ì¤€ì— ì˜ˆì¹˜í•œ ì¤€ë¹„ê¸ˆì´ ê°ì†Œí•˜ê³  ìˆë‹¤ëŠ” ëœ»ì…ë‹ˆë‹¤. ì´ê²Œ ì™œ ì¤‘ìš”í•œê°€? ì´ê±´ ê¸ˆìœµ ì‹œìŠ¤í…œì˜ 'ì•ˆì „ ì¿ ì…˜'ì´ ì¤„ì–´ë“ ë‹¤ëŠ” ì‹ í˜¸ê±°ë“ ìš”. ê±°ëŒ€ ìë³¸ê°€ë“¤ì€ ì´ëŸ° ì§€í‘œë¥¼ ë§¤ìš° ê²½ê³„í•©ë‹ˆë‹¤. ì§€ì¤€ê¸ˆì´ ì¼ì • ìˆ˜ì¤€ ì´í•˜ë¡œ ë–¨ì–´ì§€ë©´, ì€í–‰ë“¤ì´ ëˆì„ ë¹Œë¦¬ê¸° ì–´ë ¤ì›Œì§€ê³  ì‹ ìš© ê²½ìƒ‰ì´ ì‹œì‘ë  ìˆ˜ ìˆìœ¼ë‹ˆê¹Œìš”. ë¯¸êµ­ì˜ í—¤ê²Œëª¨ë‹ˆ ê´€ì ì—ì„œ ë³´ë©´, ì´ê±´ ê¸ˆìœµ ì‹œìŠ¤í…œì˜ ì·¨ì•½ì ì´ ë…¸ì¶œë˜ê³  ìˆë‹¤ëŠ” ì‹ í˜¸ì¼ ìˆ˜ ìˆì–´ìš”. í•˜ì§€ë§Œ ë™ì‹œì— ì—°ì¤€ì´ ì´ëŸ° ìƒí™©ì„ ê°ì§€í•˜ê³  ìˆë‹¤ë©´, ê³§ ê°œì…í•  ê°€ëŠ¥ì„±ë„ ìˆìŠµë‹ˆë‹¤. ë±…ê°€ë“œë‚˜ ë¸”ë™ë¡ ê°™ì€ ê¸°ê´€ë“¤ì€ ì´ëŸ° ì‹œì ì— ë” ë°©ì–´ì ìœ¼ë¡œ í¬ì§€ì…˜ì„ ì¡°ì •í•©ë‹ˆë‹¤.",
            weeklyContext.context
          );
        } else {
          return formatInterpretation(
            "ì€í–‰ ì‹œìŠ¤í…œì´ ì—¬ìœ  ìˆëŠ” ìƒíƒœì˜ˆìš”",
            "ì§€ì¤€ê¸ˆì´ ëŠ˜ì–´ë‚œë‹¤ëŠ” ê±´, ì€í–‰ë“¤ì´ ì—°ì¤€ì— ì˜ˆì¹˜í•œ ì¤€ë¹„ê¸ˆì´ ì¦ê°€í•˜ê³  ìˆë‹¤ëŠ” ëœ»ì…ë‹ˆë‹¤. ì´ê±´ ê¸ˆìœµ ì‹œìŠ¤í…œì´ ê±´ê°•í•˜ê³  ì—¬ìœ  ìˆë‹¤ëŠ” ì‹ í˜¸ì˜ˆìš”. ê±°ëŒ€ ìë³¸ê°€ë“¤ì€ ì´ëŸ° ì•ˆì •ì„±ì„ ì¢‹ì•„í•©ë‹ˆë‹¤. ì‹œìŠ¤í…œì´ ì •ìƒ ì‘ë™í•˜ë©´ ìì‚° ê°€ê²©ë„ ì•ˆì •ì ìœ¼ë¡œ ì›€ì§ì¼ ê°€ëŠ¥ì„±ì´ ë†’ìœ¼ë‹ˆê¹Œìš”. ë¯¸êµ­ì˜ í—¤ê²Œëª¨ë‹ˆ ê´€ì ì—ì„œ ë³´ë©´, ì´ê±´ ê¸€ë¡œë²Œ ê¸ˆìœµ ì‹œìŠ¤í…œì´ ë‹¬ëŸ¬ ì¤‘ì‹¬ìœ¼ë¡œ ì˜ ëŒì•„ê°€ê³  ìˆë‹¤ëŠ” ì¦ê±°ì…ë‹ˆë‹¤. ì€í–‰ë“¤ì´ ì¶©ë¶„í•œ ìœ ë™ì„±ì„ ê°€ì§€ê³  ìˆë‹¤ëŠ” ê±´, ë¯¸êµ­ì´ ê¸€ë¡œë²Œ ê¸ˆìœµ ì‹œìŠ¤í…œì„ í†µì œí•  ìˆ˜ ìˆëŠ” ì—¬ë ¥ì´ ì¶©ë¶„í•˜ë‹¤ëŠ” ëœ»ì´ì—ìš”.",
            weeklyContext.context
          );
        }
      }
      return ch > 0
        ? formatInterpretation("ì´ ì§€í‘œì˜ ì˜í–¥ë ¥ì´ ì»¤ì§€ê³  ìˆì–´ìš”", "ì´ ì§€í‘œê°€ ì»¤ì§„ë‹¤ëŠ” ê±´, ì‹œì¥ì— ë¯¸ì¹˜ëŠ” ì˜í–¥ë ¥ì´ ì¦ê°€í•˜ê³  ìˆë‹¤ëŠ” ëœ»ì…ë‹ˆë‹¤. ê±°ëŒ€ ìë³¸ê°€ë“¤ì€ ì´ëŸ° ë³€í™”ë¥¼ ì£¼ì˜ ê¹Šê²Œ ë´…ë‹ˆë‹¤. ì§€í‘œì˜ ê·œëª¨ê°€ ì»¤ì§€ë©´, ê·¸ ì§€í‘œê°€ ì‹œì¥ì— ë¯¸ì¹˜ëŠ” ì˜í–¥ë„ ì»¤ì§€ë‹ˆê¹Œìš”. ë¯¸êµ­ì˜ ì •ì±… ì˜ë„ë¥¼ ì •í™•íˆ ì½ì–´ì•¼ í•©ë‹ˆë‹¤.")
        : formatInterpretation("ì´ ì§€í‘œì˜ ì˜í–¥ë ¥ì´ ì¤„ì–´ë“¤ê³  ìˆì–´ìš”", "ì´ ì§€í‘œê°€ ì¤„ì–´ë“ ë‹¤ëŠ” ê±´, ì‹œì¥ì— ë¯¸ì¹˜ëŠ” ì˜í–¥ë ¥ì´ ê°ì†Œí•˜ê³  ìˆë‹¤ëŠ” ì‹ í˜¸ì…ë‹ˆë‹¤. ê±°ëŒ€ ìë³¸ê°€ë“¤ì€ ì´ëŸ° ë³€í™”ë¥¼ ì£¼ì˜ ê¹Šê²Œ ë´…ë‹ˆë‹¤. ì§€í‘œì˜ ê·œëª¨ê°€ ì¤„ì–´ë“¤ë©´, ê·¸ ì§€í‘œê°€ ì‹œì¥ì— ë¯¸ì¹˜ëŠ” ì˜í–¥ë„ ì¤„ì–´ë“¤ ìˆ˜ ìˆìœ¼ë‹ˆê¹Œìš”.");
  }
}

export const ITEM_DEFS: Array<{
  key: string;
  title: string;
  fedLabel: string;
  liquidityTag: H41Card["liquidityTag"];
  isCore?: boolean; // í•µì‹¬ 6ê°œ í•­ëª© í‘œì‹œ
}> = [
  { key: "â“", title: "ì¬ë¬´ë¶€ ì¼ë°˜ê³„ì • (TGA)", fedLabel: "U.S. Treasury, General Account", liquidityTag: "í¡ìˆ˜(ì•½ì¬)", isCore: true },
  { key: "â“‘", title: "ì—­ë¦¬í¬ (RRP)", fedLabel: "Reverse repurchase agreements", liquidityTag: "í¡ìˆ˜(ì•½ì¬)", isCore: true },
  { key: "â“’", title: "í†µí™”ë°œí–‰ (í˜„ê¸ˆ)", fedLabel: "Currency in circulation", liquidityTag: "í¡ìˆ˜(ì•½ì¬)" },
  { key: "â““", title: "ê¸°íƒ€ ë¶€ì±„Â·ìë³¸", fedLabel: "Other liabilities and capital", liquidityTag: "í¡ìˆ˜(ì•½ì¬)" },

  { key: "â“”", title: "ë¦¬í¬ (Repo)", fedLabel: "Repurchase agreements", liquidityTag: "ê³µê¸‰(í•´ì—´)", isCore: true },
  { key: "â“•", title: "Primary Credit", fedLabel: "Primary credit", liquidityTag: "ê³µê¸‰(í•´ì—´)", isCore: true },
  { key: "â“–", title: "ë‹¬ëŸ¬ ìŠ¤ì™‘ (ì¤‘ì•™ì€í–‰)", fedLabel: "Central bank liquidity swaps", liquidityTag: "ê³µê¸‰(í•´ì—´)" },

  { key: "â“—", title: "ë³´ìœ ì¦ê¶Œ ì´ê³„", fedLabel: "Securities held outright", liquidityTag: "QT/ìì‚°", isCore: true },
  { key: "â“˜", title: "ë¯¸êµ­ êµ­ì±„ ë³´ìœ  (UST)", fedLabel: "U.S. Treasury securities", liquidityTag: "QT/ìì‚°" },
  { key: "â“™", title: "MBS ë³´ìœ ", fedLabel: "Mortgage-backed securities", liquidityTag: "QT/ìì‚°" },

  { key: "â“š", title: "ì§€ì¤€ê¸ˆ (Reserve balances)", fedLabel: "Reserve balances with Federal Reserve Banks", liquidityTag: "ìƒíƒœ", isCore: true },
  { key: "â“›", title: "Fed ìì‚° ì´ê·œëª¨ (Reserve Bank credit)", fedLabel: "Reserve Bank credit", liquidityTag: "ìƒíƒœ" },
  { key: "â“œ", title: "ê¸°íƒ€ ì˜ˆì¹˜ê¸ˆ (ì§€ì¤€ê¸ˆ ì œì™¸)", fedLabel: "Deposits with F.R. Banks, other than reserve balances", liquidityTag: "ìƒíƒœ" },
  { key: "â“", title: "í¡ìˆ˜ ì´í•© (ì§€ì¤€ê¸ˆ ì œì™¸)", fedLabel: "Total factors, other than reserve balances,", liquidityTag: "ìƒíƒœ" }
];

// í•µì‹¬ 6ê°œ í•­ëª©ì˜ fedLabel ëª©ë¡
const CORE_FED_LABELS = [
  "U.S. Treasury, General Account",
  "Reverse repurchase agreements",
  "Reserve balances with Federal Reserve Banks",
  "Securities held outright",
  "Repurchase agreements",
  "Primary credit"
];

/**
 * ê²½ê³  ë ˆë²¨ ê³„ì‚° (LEVEL 0~3)
 * ìœ ë™ì„± í¡ìˆ˜ ìš”ì¸ê³¼ QT ì§„í–‰ ì†ë„ë¥¼ ì¢…í•© í‰ê°€
 */
function calculateWarningLevel(cards: H41Card[]): WarningLevel {
  // í•µì‹¬ í•­ëª© ì°¾ê¸°
  const tga = cards.find(c => c.fedLabel === "U.S. Treasury, General Account");
  const rrp = cards.find(c => c.fedLabel === "Reverse repurchase agreements");
  const reserves = cards.find(c => c.fedLabel === "Reserve balances with Federal Reserve Banks");
  const securities = cards.find(c => c.fedLabel === "Securities held outright");
  const repo = cards.find(c => c.fedLabel === "Repurchase agreements");
  const primaryCredit = cards.find(c => c.fedLabel === "Primary credit");

  let score = 0;

  // TGA ì¦ê°€ = ìœ ë™ì„± í¡ìˆ˜ ê°•í™”
  if (tga && tga.change_musd > 50000) score += 1; // 500ì–µ ì´ìƒ ì¦ê°€
  if (tga && tga.change_musd > 100000) score += 1; // 1000ì–µ ì´ìƒ ì¦ê°€

  // RRP ì¦ê°€ = ìœ ë™ì„± í¡ìˆ˜ ê°•í™”
  if (rrp && rrp.change_musd > 30000) score += 1;
  if (rrp && rrp.change_musd > 60000) score += 1;

  // ì§€ì¤€ê¸ˆ ê°ì†Œ = ì‹œìŠ¤í…œ ì¿ ì…˜ ì¶•ì†Œ
  if (reserves && reserves.change_musd < -50000) score += 1;
  if (reserves && reserves.change_musd < -100000) score += 1;

  // QT ì§„í–‰ (ë³´ìœ ì¦ê¶Œ ê°ì†Œ)
  if (securities && securities.change_musd < -50000) score += 1;
  if (securities && securities.change_musd < -100000) score += 1;

  // ê³µê¸‰ ìš”ì¸ ê°ì†Œ (Repo, Primary Credit ê°ì†Œ)
  const supplyDecrease = (repo?.change_musd ?? 0) + (primaryCredit?.change_musd ?? 0);
  if (supplyDecrease < -20000) score += 1;

  // ì ìˆ˜ì— ë”°ë¼ ë ˆë²¨ ê²°ì •
  if (score >= 6) return 3;
  if (score >= 4) return 2;
  if (score >= 2) return 1;
  return 0;
}

/**
 * ê²½ê³  ë ˆë²¨ë³„ ìì‚°êµ° ëŒ€ì‘ ê°€ì´ë“œ
 */
function getAssetGuidance(level: WarningLevel): string {
  const guides: Record<WarningLevel, string> = {
    0: "ìœ ë™ì„± í™˜ê²½ì´ ì•ˆì •ì ì¸ êµ­ë©´ì…ë‹ˆë‹¤.\nì„±ì¥ì£¼, ê¸°ìˆ ì£¼, ì¥ê¸° í…Œë§ˆ ìì‚°ì— ëŒ€í•œ ë¹„ì¤‘ í™•ëŒ€ê°€ ê°€ëŠ¥í•œ êµ¬ê°„ì…ë‹ˆë‹¤.",
    1: "ìœ ë™ì„± í¡ìˆ˜ ì‹ í˜¸ê°€ ì¼ë¶€ ê´€ì¸¡ë©ë‹ˆë‹¤.\nê³µê²©ì  ìì‚° ë¹„ì¤‘ì€ ìœ ì§€í•˜ë˜, ë³€ë™ì„± í™•ëŒ€ì— ëŒ€ë¹„í•œ ë¶„ì‚°ì´ í•„ìš”í•œ êµ­ë©´ì…ë‹ˆë‹¤.",
    2: "ìœ ë™ì„± ì••ë°•ì´ ê°€ì‹œí™”ë˜ê³  ìˆìŠµë‹ˆë‹¤.\në°©ì–´ì  ìì‚°ê³¼ í˜„ê¸ˆì„± ë¹„ì¤‘ì„ ì ì§„ì ìœ¼ë¡œ ë†’ì¼ í•„ìš”ê°€ ìˆìŠµë‹ˆë‹¤.",
    3: "ìœ ë™ì„± ê¸‰ê°ê³¼ ê¸´ì¶• ê°€ì†ì´ ë™ì‹œì— ì§„í–‰ ì¤‘ì…ë‹ˆë‹¤.\nê³ ìœ„í—˜ ìì‚° ë¹„ì¤‘ ì¶•ì†Œì™€ ë°©ì–´ì  í¬ì§€ì…˜ ìœ ì§€ê°€ ìš°ì„ ë˜ëŠ” êµ­ë©´ì…ë‹ˆë‹¤."
  };
  return guides[level];
}

/**
 * ì²­íŒ€/ë°±íŒ€ ì‹œê·¸ë„ ìƒì„±
 */
function getTeamSignal(level: WarningLevel): TeamSignal {
  const signals: Record<WarningLevel, TeamSignal> = {
    0: {
      blueTeam: "ë¹„ì¤‘ í™•ëŒ€ ê°€ëŠ¥",
      whiteTeam: "ê¸°ë³¸ ìœ ì§€",
      summary: "ì²­íŒ€ ìš°í˜¸ì  í™˜ê²½ Â· ë°±íŒ€ ì¤‘ë¦½"
    },
    1: {
      blueTeam: "ì„ ë³„ì  ìœ ì§€",
      whiteTeam: "ì ì§„ì  ê´€ì‹¬",
      summary: "ì²­íŒ€ ìœ ì§€ Â· ë°±íŒ€ ê´€ì°° í•„ìš”"
    },
    2: {
      blueTeam: "ë¹„ì¤‘ ì¶•ì†Œ ê¶Œì¥",
      whiteTeam: "ë¹„ì¤‘ í™•ëŒ€ êµ¬ê°„",
      summary: "ì²­íŒ€ ë¦¬ìŠ¤í¬ ê´€ë¦¬ í•„ìš” Â· ë°±íŒ€ ìš°ì„¸ êµ­ë©´"
    },
    3: {
      blueTeam: "ë°©ì–´ì  ì¶•ì†Œ",
      whiteTeam: "í•µì‹¬ í¬ì§€ì…˜",
      summary: "ì²­íŒ€ ë°©ì–´ ì „í™˜ Â· ë°±íŒ€ ì¤‘ì‹¬ ëŒ€ì‘"
    }
  };
  return signals[level];
}

/**
 * ì£¼ê°„ ìš”ì•½ ë¦¬í¬íŠ¸ ìƒì„± (ìƒì„¸ ë²„ì „)
 */
function generateWeeklySummary(cards: H41Card[], level: WarningLevel, teamSignal: TeamSignal): string {
  const tga = cards.find(c => c.fedLabel === "U.S. Treasury, General Account");
  const rrp = cards.find(c => c.fedLabel === "Reverse repurchase agreements");
  const reserves = cards.find(c => c.fedLabel === "Reserve balances with Federal Reserve Banks");
  const securities = cards.find(c => c.fedLabel === "Securities held outright");
  const repo = cards.find(c => c.fedLabel === "Repurchase agreements");
  const primaryCredit = cards.find(c => c.fedLabel === "Primary credit");
  const currency = cards.find(c => c.fedLabel === "Currency in circulation");
  const reserveBankCredit = cards.find(c => c.fedLabel === "Reserve Bank credit");
  const ust = cards.find(c => c.fedLabel === "U.S. Treasury securities");
  const mbs = cards.find(c => c.fedLabel === "Mortgage-backed securities");

  const parts: string[] = [];

  // 0) ì£¼ìš” ë¬¸êµ¬ (20ì ë‚´ì™¸, ë³¼ë“œ+ì´ëª¨ì§€)
  const levelText = ["ì•ˆì •", "ì£¼ì˜", "ê²½ê³„", "ìœ„í—˜"][level];
  const mainPhrases = {
    0: "âœ… í° ì†ë“¤ì´ ì›€ì§ì¼ ì—¬ìœ ê°€ ìˆëŠ” êµ¬ê°„",
    1: "âš ï¸ ê±°ëŒ€ ìë³¸ê°€ë“¤ì´ ì‹ ì¤‘í•´ì§€ëŠ” ì‹œì ",
    2: "ğŸ”¶ ë¯¸êµ­ì´ ìœ ë™ì„±ì„ ì¡°ì ˆí•˜ê³  ìˆì–´ìš”",
    3: "ğŸš¨ ê¸ˆìœµíŒ¨ê¶Œìë“¤ì´ ë°©ì–´ ëª¨ë“œë¡œ ì „í™˜"
  };
  parts.push(`**${mainPhrases[level]}**`);

  // 1) ì´ë²ˆ ì£¼ ê±°ì‹œê²½ì œ ì´ë©´ ì½ê¸°
  parts.push(`\n[ì´ë²ˆ ì£¼ ê±°ì‹œê²½ì œ ì´ë©´ ì½ê¸°]`);
  
  if (level >= 2) {
    parts.push(`ì´ë²ˆ ì£¼ ë°ì´í„°ë¥¼ ë³´ë©´, ë¯¸êµ­ì´ ê¸€ë¡œë²Œ ë‹¬ëŸ¬ ìœ ë™ì„±ì„ **ì˜ë„ì ìœ¼ë¡œ ì¡°ì ˆ**í•˜ê³  ìˆë‹¤ëŠ” ê²Œ ë³´ì—¬ìš”. TGAì™€ RRPê°€ ë™ì‹œì— ëŠ˜ì–´ë‚œë‹¤ëŠ” ê±´, ì‹œì¥ì—ì„œ ëˆì„ ë¹¨ì•„ë“¤ì´ëŠ” ë©”ì»¤ë‹ˆì¦˜ì´ ì‘ë™í•˜ê³  ìˆë‹¤ëŠ” ëœ»ì…ë‹ˆë‹¤. ì´ê²Œ ë‹¨ìˆœíˆ 'ìœ ë™ì„± ë¶€ì¡±'ì´ ì•„ë‹ˆë¼, ë¯¸êµ­ì´ **ë‹¬ëŸ¬ ê°•ì„¸ë¥¼ ìœ ì§€**í•˜ë©´ì„œ **ê¸€ë¡œë²Œ ìë³¸ì„ ë¯¸êµ­ìœ¼ë¡œ ëŒì–´ë“¤ì´ëŠ” ì „ëµ**ì˜ ì¼ë¶€ë¡œ ì½í˜€ìš”.`);
    parts.push(`ë¸”ë™ë¡ì´ë‚˜ ë±…ê°€ë“œ ê°™ì€ ê±°ëŒ€ ìë³¸ê°€ë“¤ì€ ì´ëŸ° ì‹œì ì„ ë§¤ìš° ì£¼ì˜ ê¹Šê²Œ ë´…ë‹ˆë‹¤. ìœ ë™ì„±ì´ ì¤„ì–´ë“¤ë©´ ìì‚° ê°€ê²©ì— ì••ë°•ì´ ê°€í•´ì§€ë‹ˆê¹Œ, ì´ë“¤ì€ í¬íŠ¸í´ë¦¬ì˜¤ë¥¼ ë” ë°©ì–´ì ìœ¼ë¡œ ì¡°ì •í•©ë‹ˆë‹¤. íŠ¹íˆ ê³ ë³€ë™ì„± ìì‚°ì˜ ë¹„ì¤‘ì„ ì¤„ì´ê³ , í˜„ê¸ˆì´ë‚˜ ë°©ì–´ì  ìì‚°ìœ¼ë¡œ ì „í™˜í•˜ëŠ” ì›€ì§ì„ì´ ë³´ì—¬ìš”.`);
  } else if (level === 1) {
    parts.push(`ì´ë²ˆ ì£¼ëŠ” ì¼ë¶€ ì‹ í˜¸ë“¤ì´ ì„ì—¬ ìˆì–´ìš”. TGAë‚˜ RRP ê°™ì€ í¡ìˆ˜ ìš”ì¸ì´ ì¡°ê¸ˆì”© ë³´ì´ì§€ë§Œ, ì•„ì§ì€ **ì‹œìŠ¤í…œì´ ì•ˆì •ì ìœ¼ë¡œ ëŒì•„ê°€ê³  ìˆëŠ”** ìƒíƒœì…ë‹ˆë‹¤. ê±°ëŒ€ ìë³¸ê°€ë“¤ì˜ ê´€ì ì—ì„œ ë³´ë©´, ì´ê±´ 'ê´€ì°° ëª¨ë“œ'ì— ë“¤ì–´ê°„ ì‹œì ì´ì—ìš”.`);
    parts.push(`ë±…ê°€ë“œë‚˜ ë¸”ë™ë¡ ê°™ì€ ê¸°ê´€ë“¤ì€ ì´ëŸ° í™˜ê²½ì—ì„œ í¬ì§€ì…˜ì„ í¬ê²Œ ë°”ê¾¸ì§€ ì•ŠìŠµë‹ˆë‹¤. í•˜ì§€ë§Œ ìœ ë™ì„± ì••ë°• ì‹ í˜¸ê°€ ê³„ì†ë˜ë©´, ê³§ ë°©ì–´ì ìœ¼ë¡œ ì „í™˜í•  ì¤€ë¹„ë¥¼ í•˜ê³  ìˆì–´ìš”.`);
  } else {
    parts.push(`ì´ë²ˆ ì£¼ ë°ì´í„°ë¥¼ ë³´ë©´, ìœ ë™ì„± í™˜ê²½ì´ ë¹„êµì  **ì•ˆì •ì ìœ¼ë¡œ ìœ ì§€**ë˜ê³  ìˆì–´ìš”. ì´ê±´ ë¯¸êµ­ì´ ê¸€ë¡œë²Œ ê¸ˆìœµ ì‹œìŠ¤í…œì„ í†µì œí•  ìˆ˜ ìˆëŠ” ì—¬ë ¥ì´ ì¶©ë¶„í•˜ë‹¤ëŠ” ì‹ í˜¸ì…ë‹ˆë‹¤.`);
    parts.push(`ê±°ëŒ€ ìë³¸ê°€ë“¤ì˜ ê´€ì ì—ì„œ ë³´ë©´, ì´ëŸ° ì•ˆì •ì„±ì€ ê¸°íšŒì˜ˆìš”. ìœ ë™ì„±ì´ ì¶©ë¶„í•˜ë©´ ìì‚° ê°€ê²©ì´ ì˜¤ë¥¼ ì—¬ì§€ê°€ ìƒê¸°ë‹ˆê¹Œ, ë±…ê°€ë“œë‚˜ ë¸”ë™ë¡ ê°™ì€ ê¸°ê´€ë“¤ì€ ì´ëŸ° ì‹œì ì— ì„±ì¥ ìì‚°ì˜ ë¹„ì¤‘ì„ ëŠ˜ë¦½ë‹ˆë‹¤.`);
  }

  // 2) í•µì‹¬ ì§€í‘œì˜ ì§„ì§œ ì˜ë¯¸
  parts.push(`\n[í•µì‹¬ ì§€í‘œì˜ ì§„ì§œ ì˜ë¯¸]`);
  
  if (tga) {
    const tgaDir = tga.change_okeusd > 0 ? "ì¦ê°€" : tga.change_okeusd < 0 ? "ê°ì†Œ" : "ë³€ë™ì—†ìŒ";
    const tgaAbs = Math.abs(tga.change_okeusd);
    if (tga.change_okeusd > 0) {
      parts.push(`â€¢ **ì¬ë¬´ë¶€ ê³„ì •(TGA)ì´ ${tgaAbs.toFixed(1)}ì–µ ë‹¬ëŸ¬ ëŠ˜ì–´ë‚¬ì–´ìš”** - ì´ê±´ ë¯¸êµ­ ì •ë¶€ê°€ ì„¸ê¸ˆì„ ë°›ê±°ë‚˜ êµ­ì±„ë¥¼ íŒ”ì•„ì„œ ìê¸ˆì„ ëª¨ìœ¼ê³  ìˆë‹¤ëŠ” ëœ»ì…ë‹ˆë‹¤. ì´ê²Œ ì™œ ì¤‘ìš”í•œê°€? ë¯¸êµ­ì´ ê¸€ë¡œë²Œ ë‹¬ëŸ¬ ìœ ë™ì„±ì„ ì¡°ì ˆí•˜ëŠ” í•µì‹¬ ìˆ˜ë‹¨ì´ê±°ë“ ìš”. TGAê°€ ì»¤ì§€ë©´ ì‹œì¥ì— ëŒì•„ë‹¤ë‹ˆëŠ” ë‹¬ëŸ¬ê°€ ì¤„ì–´ë“¤ì–´ì„œ, ì „ ì„¸ê³„ ìì‚° ê°€ê²©ì— ì••ë°•ì´ ê°€í•´ì§‘ë‹ˆë‹¤.`);
    } else if (tga.change_okeusd < 0) {
      parts.push(`â€¢ **ì¬ë¬´ë¶€ ê³„ì •(TGA)ì´ ${tgaAbs.toFixed(1)}ì–µ ë‹¬ëŸ¬ ì¤„ì–´ë“¤ì—ˆì–´ìš”** - ì´ê±´ ì •ë¶€ê°€ ì§€ì¶œì„ ëŠ˜ë¦¬ê³  ìˆë‹¤ëŠ” ì‹ í˜¸ì…ë‹ˆë‹¤. ê±°ëŒ€ ìë³¸ê°€ë“¤ì€ ì´ëŸ° ì‹œì ì„ ë…¸ë¦½ë‹ˆë‹¤. ìœ ë™ì„±ì´ í’€ë¦¬ë©´ì„œ ìì‚° ê°€ê²©ì´ ì˜¤ë¥¼ ì—¬ì§€ê°€ ìƒê¸°ë‹ˆê¹Œìš”.`);
    } else {
      parts.push(`â€¢ **ì¬ë¬´ë¶€ ê³„ì •(TGA)ì´ ë³€ë™ì´ ì—†ì–´ìš”** - ì´ê±´ ì—°ì¤€ê³¼ ì¬ë¬´ë¶€ê°€ ì˜ë„ì ìœ¼ë¡œ ì´ ìˆ˜ì¤€ì„ ìœ ì§€í•˜ê³  ìˆë‹¤ëŠ” ì‹ í˜¸ì…ë‹ˆë‹¤.`);
    }
  }
  
  if (rrp) {
    const rrpDir = rrp.change_okeusd > 0 ? "ì¦ê°€" : rrp.change_okeusd < 0 ? "ê°ì†Œ" : "ë³€ë™ì—†ìŒ";
    const rrpAbs = Math.abs(rrp.change_okeusd);
    if (rrp.change_okeusd > 0) {
      parts.push(`â€¢ **ì—­ë¦¬í¬(RRP)ê°€ ${rrpAbs.toFixed(1)}ì–µ ë‹¬ëŸ¬ ëŠ˜ì–´ë‚¬ì–´ìš”** - ì´ê±´ ë±…ê°€ë“œë‚˜ ë¸”ë™ë¡ ê°™ì€ ê±°ëŒ€ ê¸ˆìœµê¸°ê´€ë“¤ì´ 'ì•ˆì „í•œ ê³³'ì— ëˆì„ ë§¡ê¸°ê³  ìˆë‹¤ëŠ” ì‹ í˜¸ì…ë‹ˆë‹¤. ì´ë“¤ì´ ì‹œì¥ì—ì„œ ê°€ì¥ ì˜ˆë¦¬í•œ ëˆˆì„ ê°€ì§„ ìë³¸ê°€ë“¤ì´ê±°ë“ ìš”. RRPì— ëˆì„ ë§¡ê¸´ë‹¤ëŠ” ê±´, ì§€ê¸ˆ ì‹œì¥ì— ë§¤ë ¥ì ì¸ íˆ¬ìì²˜ê°€ ì—†ë‹¤ê³  íŒë‹¨í•˜ê±°ë‚˜, ê³§ ë³€ë™ì„±ì´ ì»¤ì§ˆ ê±°ë¼ê³  ì˜ˆìƒí•œë‹¤ëŠ” ëœ»ì…ë‹ˆë‹¤.`);
    } else if (rrp.change_okeusd < 0) {
      parts.push(`â€¢ **ì—­ë¦¬í¬(RRP)ê°€ ${rrpAbs.toFixed(1)}ì–µ ë‹¬ëŸ¬ ì¤„ì–´ë“¤ì—ˆì–´ìš”** - ì´ê±´ ê±°ëŒ€ ìë³¸ê°€ë“¤ì´ 'ì´ì œ ì›€ì§ì¼ ë•Œë‹¤'ê³  íŒë‹¨í–ˆë‹¤ëŠ” ì‹ í˜¸ì…ë‹ˆë‹¤. ì´ëŸ° ì›€ì§ì„ì€ ë³´í†µ ìì‚° ê°€ê²© ìƒìŠ¹ì˜ ì „ì¡°ê°€ ë©ë‹ˆë‹¤.`);
    }
  }
  
  if (reserves) {
    const resDir = reserves.change_okeusd > 0 ? "ì¦ê°€" : reserves.change_okeusd < 0 ? "ê°ì†Œ" : "ë³€ë™ì—†ìŒ";
    const resAbs = Math.abs(reserves.change_okeusd);
    if (reserves.change_okeusd < 0) {
      parts.push(`â€¢ **ì§€ì¤€ê¸ˆì´ ${resAbs.toFixed(1)}ì–µ ë‹¬ëŸ¬ ì¤„ì–´ë“¤ì—ˆì–´ìš”** - ì´ê±´ ê¸ˆìœµ ì‹œìŠ¤í…œì˜ 'ì•ˆì „ ì¿ ì…˜'ì´ ì¤„ì–´ë“ ë‹¤ëŠ” ì‹ í˜¸ì…ë‹ˆë‹¤. ê±°ëŒ€ ìë³¸ê°€ë“¤ì€ ì´ëŸ° ì§€í‘œë¥¼ ë§¤ìš° ê²½ê³„í•©ë‹ˆë‹¤. ì§€ì¤€ê¸ˆì´ ì¼ì • ìˆ˜ì¤€ ì´í•˜ë¡œ ë–¨ì–´ì§€ë©´, ì€í–‰ë“¤ì´ ëˆì„ ë¹Œë¦¬ê¸° ì–´ë ¤ì›Œì§€ê³  ì‹ ìš© ê²½ìƒ‰ì´ ì‹œì‘ë  ìˆ˜ ìˆìœ¼ë‹ˆê¹Œìš”.`);
    } else if (reserves.change_okeusd > 0) {
      parts.push(`â€¢ **ì§€ì¤€ê¸ˆì´ ${resAbs.toFixed(1)}ì–µ ë‹¬ëŸ¬ ëŠ˜ì–´ë‚¬ì–´ìš”** - ì´ê±´ ê¸ˆìœµ ì‹œìŠ¤í…œì´ ê±´ê°•í•˜ê³  ì—¬ìœ  ìˆë‹¤ëŠ” ì‹ í˜¸ì…ë‹ˆë‹¤. ê±°ëŒ€ ìë³¸ê°€ë“¤ì€ ì´ëŸ° ì•ˆì •ì„±ì„ ì¢‹ì•„í•©ë‹ˆë‹¤. ì‹œìŠ¤í…œì´ ì •ìƒ ì‘ë™í•˜ë©´ ìì‚° ê°€ê²©ë„ ì•ˆì •ì ìœ¼ë¡œ ì›€ì§ì¼ ê°€ëŠ¥ì„±ì´ ë†’ìœ¼ë‹ˆê¹Œìš”.`);
    }
  }

  // 3) ì—°ì¤€ì˜ ì§„ì§œ ì˜ë„ ì½ê¸°
  parts.push(`\n[ì—°ì¤€ì˜ ì§„ì§œ ì˜ë„ ì½ê¸°]`);
  if (securities) {
    const secDir = securities.change_okeusd > 0 ? "ì¦ê°€" : securities.change_okeusd < 0 ? "ê°ì†Œ" : "ë³€ë™ì—†ìŒ";
    const secAbs = Math.abs(securities.change_okeusd);
    if (securities.change_okeusd < 0) {
      parts.push(`â€¢ **ì—°ì¤€ì´ ë³´ìœ ì¦ê¶Œì„ ${secAbs.toFixed(1)}ì–µ ë‹¬ëŸ¬ ì¤„ì˜€ì–´ìš”** - ì´ê±´ ì–‘ì ê¸´ì¶•(QT)ì´ ì§„í–‰ë˜ê³  ìˆë‹¤ëŠ” ëœ»ì…ë‹ˆë‹¤. ê±°ëŒ€ ìë³¸ê°€ë“¤ì˜ ê´€ì ì—ì„œ ë³´ë©´, ì´ê±´ ë¯¸êµ­ì´ ê¸€ë¡œë²Œ ë‹¬ëŸ¬ ìœ ë™ì„±ì„ ì¡°ì ˆí•˜ë©´ì„œ ìì‚° ê°€ê²©ì„ í†µì œí•˜ë ¤ëŠ” ì „ëµì…ë‹ˆë‹¤. ë¸”ë™ë¡ì´ë‚˜ ë±…ê°€ë“œ ê°™ì€ ê¸°ê´€ë“¤ì€ QTê°€ ì§„í–‰ë  ë•Œ í¬íŠ¸í´ë¦¬ì˜¤ë¥¼ ë” ë°©ì–´ì ìœ¼ë¡œ ì¡°ì •í•©ë‹ˆë‹¤.`);
      parts.push(`  ë¯¸êµ­ì˜ í—¤ê²Œëª¨ë‹ˆ ê´€ì ì—ì„œ ë³´ë©´, ì´ê±´ ë‹¬ëŸ¬ ê°•ì„¸ë¥¼ ìœ ì§€í•˜ê³  ê¸€ë¡œë²Œ ìë³¸ì„ ë¯¸êµ­ìœ¼ë¡œ ëŒì–´ë“¤ì´ëŠ” ìˆ˜ë‹¨ì´ì—ìš”. QTê°€ ë¹ ë¥¼ìˆ˜ë¡ ì‹œì¥ ë³€ë™ì„±ì´ ì»¤ì§ˆ ìˆ˜ ìˆìœ¼ë‹ˆ, ê±°ëŒ€ ìë³¸ê°€ë“¤ì€ ì´ëŸ° ì‹œì ì— í˜„ê¸ˆ ë¹„ì¤‘ì„ ëŠ˜ë¦¬ê±°ë‚˜ ë°©ì–´ì  ìì‚°ìœ¼ë¡œ ì „í™˜í•©ë‹ˆë‹¤.`);
    } else if (securities.change_okeusd > 0) {
      parts.push(`â€¢ **ì—°ì¤€ì˜ ë³´ìœ ì¦ê¶Œì´ ${secAbs.toFixed(1)}ì–µ ë‹¬ëŸ¬ ëŠ˜ì–´ë‚¬ì–´ìš”** - ì´ê±´ QTê°€ ì¼ì‹œì ìœ¼ë¡œ ì¤‘ë‹¨ë˜ê±°ë‚˜ ë°˜ì „ ì‹ í˜¸ì¼ ìˆ˜ ìˆì–´ìš”. ê±°ëŒ€ ìë³¸ê°€ë“¤ì€ ì´ëŸ° ë³€í™”ë¥¼ ë§¤ìš° ì£¼ì˜ ê¹Šê²Œ ë´…ë‹ˆë‹¤.`);
    } else {
      parts.push(`â€¢ **ì—°ì¤€ì˜ ë³´ìœ ì¦ê¶Œì´ ë³€ë™ì´ ì—†ì–´ìš”** - ì´ê±´ ì—°ì¤€ì´ ì‹œì¥ ë°˜ì‘ì„ ì§€ì¼œë³´ë©´ì„œ ì†ë„ë¥¼ ì¡°ì ˆí•˜ê³  ìˆë‹¤ëŠ” ëœ»ì…ë‹ˆë‹¤.`);
    }
  }

  // 4) ê±°ëŒ€ ìë³¸ê°€ë“¤ì´ ì§€ê¸ˆ ë­˜ í•˜ê³  ìˆëŠ”ê°€
  parts.push(`\n[ê±°ëŒ€ ìë³¸ê°€ë“¤ì´ ì§€ê¸ˆ ë­˜ í•˜ê³  ìˆëŠ”ê°€]`);
  if (repo && repo.change_okeusd > 0) {
    parts.push(`â€¢ **ì—°ì¤€ì´ Repoë¥¼ ëŠ˜ë¦¬ê³  ìˆì–´ìš”** - ì´ê±´ ì—°ì¤€ì´ ì‹œì¥ì˜ ìœ ë™ì„± ë¶€ì¡±ì„ ê°ì§€í•˜ê³  ì ê·¹ì ìœ¼ë¡œ ê°œì…í•˜ê³  ìˆë‹¤ëŠ” ì‹ í˜¸ì…ë‹ˆë‹¤. ê±°ëŒ€ ìë³¸ê°€ë“¤ì€ ì´ëŸ° ì›€ì§ì„ì„ ë§¤ìš° ì£¼ì˜ ê¹Šê²Œ ë´…ë‹ˆë‹¤. ì—°ì¤€ì´ 'ì‹œì¥ì„ êµ¬ì œ'í•˜ë ¤ê³  ë‚˜ì„ ë‹¤ëŠ” ê±´, ë­”ê°€ ë¬¸ì œê°€ ìˆë‹¤ëŠ” ëœ»ì¼ ìˆ˜ë„ ìˆê±°ë“ ìš”.`);
  }
  if (primaryCredit && primaryCredit.change_okeusd > 0) {
    parts.push(`â€¢ **Primary Creditì´ ëŠ˜ì–´ë‚¬ì–´ìš”** - ì´ê±´ ì€í–‰ë“¤ì´ ì‹œì¥ì—ì„œ ëˆì„ ëª» ë¹Œë ¤ì„œ ì—°ì¤€ì— ì§ì ‘ ì™€ì„œ ë¹Œë¦¬ê³  ìˆë‹¤ëŠ” ëœ»ì…ë‹ˆë‹¤. ì´ê±´ ê¸ˆìœµ ì‹œìŠ¤í…œì— ìŠ¤íŠ¸ë ˆìŠ¤ê°€ ìˆë‹¤ëŠ” ì‹ í˜¸ì˜ˆìš”. ê±°ëŒ€ ìë³¸ê°€ë“¤ì€ ì´ëŸ° ì§€í‘œë¥¼ ë§¤ìš° ê²½ê³„í•©ë‹ˆë‹¤.`);
  }

  // 5) ì¢…í•© íŒë‹¨ - ì½”ì¹˜ ê´€ì 
  parts.push(`\n[ì¢…í•© íŒë‹¨ - ì½”ì¹˜ ê´€ì ]`);
  if (level >= 2) {
    parts.push(`ì§€ê¸ˆ ìƒí™©ì„ ì •ë¦¬í•˜ë©´, ë¯¸êµ­ì´ **ì˜ë„ì ìœ¼ë¡œ ìœ ë™ì„±ì„ ì¡°ì ˆ**í•˜ê³  ìˆì–´ìš”. ì´ê±´ ë‹¨ìˆœíˆ 'ê²½ì œ ì •ì±…'ì´ ì•„ë‹ˆë¼, **ê¸€ë¡œë²Œ ê¸ˆìœµ í—¤ê²Œëª¨ë‹ˆë¥¼ ìœ ì§€í•˜ëŠ” ì „ëµ**ì˜ ì¼ë¶€ì…ë‹ˆë‹¤.`);
    parts.push(`ê±°ëŒ€ ìë³¸ê°€ë“¤(ë±…ê°€ë“œ, ë¸”ë™ë¡ ë“±)ì€ ì´ëŸ° í™˜ê²½ì—ì„œ **ë°©ì–´ì ìœ¼ë¡œ í¬ì§€ì…˜ì„ ì¡°ì •**í•©ë‹ˆë‹¤. ê³ ë³€ë™ì„± ìì‚°ì˜ ë¹„ì¤‘ì„ ì¤„ì´ê³ , í˜„ê¸ˆì´ë‚˜ ë°©ì–´ì  ìì‚°ìœ¼ë¡œ ì „í™˜í•˜ëŠ” ì›€ì§ì„ì´ ë³´ì—¬ìš”. ë‹¹ì‹ ë„ ì´ë“¤ì˜ ì›€ì§ì„ì„ ì°¸ê³ í•´ì„œ í¬íŠ¸í´ë¦¬ì˜¤ë¥¼ ì¡°ì •í•˜ëŠ” ê²Œ ì¢‹ì„ ê²ƒ ê°™ì•„ìš”.`);
  } else if (level === 1) {
    parts.push(`ì§€ê¸ˆì€ **ê´€ì°° ëª¨ë“œ**ì— ë“¤ì–´ê°„ ì‹œì ì´ì—ìš”. ì¼ë¶€ ì••ë°• ì‹ í˜¸ê°€ ë³´ì´ì§€ë§Œ, ì•„ì§ì€ ì‹œìŠ¤í…œì´ ì•ˆì •ì ìœ¼ë¡œ ëŒì•„ê°€ê³  ìˆìŠµë‹ˆë‹¤.`);
    parts.push(`ê±°ëŒ€ ìë³¸ê°€ë“¤ì€ ì´ëŸ° í™˜ê²½ì—ì„œ í¬ì§€ì…˜ì„ í¬ê²Œ ë°”ê¾¸ì§€ ì•Šì§€ë§Œ, ìœ ë™ì„± ì••ë°• ì‹ í˜¸ê°€ ê³„ì†ë˜ë©´ ê³§ ë°©ì–´ì ìœ¼ë¡œ ì „í™˜í•  ì¤€ë¹„ë¥¼ í•˜ê³  ìˆì–´ìš”. ë‹¹ì‹ ë„ ì´ëŸ° ì‹ í˜¸ë“¤ì„ ì£¼ì˜ ê¹Šê²Œ ì§€ì¼œë´ì•¼ í•©ë‹ˆë‹¤.`);
  } else {
    parts.push(`ì§€ê¸ˆì€ **ê±°ëŒ€ ìë³¸ê°€ë“¤ì´ ì›€ì§ì¼ ì—¬ìœ ê°€ ìˆëŠ” êµ¬ê°„**ì´ì—ìš”. ìœ ë™ì„±ì´ ì¶©ë¶„í•˜ë©´ ìì‚° ê°€ê²©ì´ ì˜¤ë¥¼ ì—¬ì§€ê°€ ìƒê¸°ë‹ˆê¹Œ, ë±…ê°€ë“œë‚˜ ë¸”ë™ë¡ ê°™ì€ ê¸°ê´€ë“¤ì€ ì´ëŸ° ì‹œì ì— ì„±ì¥ ìì‚°ì˜ ë¹„ì¤‘ì„ ëŠ˜ë¦½ë‹ˆë‹¤.`);
    parts.push(`í•˜ì§€ë§Œ ì—¬ê¸°ì„œ ì¤‘ìš”í•œ ê±´, ì´ê²Œ ì¼ì‹œì ì¸ì§€ ì§€ì†ì ì¸ì§€ íŒë‹¨í•˜ëŠ” ê±°ì˜ˆìš”. ë¯¸êµ­ì˜ ì •ì±… ì˜ë„ë¥¼ ì •í™•íˆ ì½ì–´ì•¼ í•©ë‹ˆë‹¤. ê±°ëŒ€ ìë³¸ê°€ë“¤ì˜ ë‹¤ìŒ ì›€ì§ì„ì„ ì£¼ì˜ ê¹Šê²Œ ì§€ì¼œë³´ì„¸ìš”.`);
  }

  // 6) ìì‚°êµ° ê´€ì  - ì½”ì¹˜ ì¡°ì–¸
  parts.push(`\n[ìì‚°êµ° ê´€ì  - ì½”ì¹˜ ì¡°ì–¸]`);
  parts.push(`**${teamSignal.summary}**`);
  parts.push(`â€¢ ì²­íŒ€(ì„±ì¥Â·ë¯¸ë˜ ìì‚°): **${teamSignal.blueTeam}**`);
  parts.push(`â€¢ ë°±íŒ€(ë°©ì–´Â·í˜„ê¸ˆíë¦„ ìì‚°): **${teamSignal.whiteTeam}**`);
  if (level >= 2) {
    parts.push(`ì§€ê¸ˆì€ **ë°©ì–´ì  ìì‚°**ì— ìœ ë¦¬í•œ í™˜ê²½ì´ì—ìš”. ê±°ëŒ€ ìë³¸ê°€ë“¤ì´ ê³ ë³€ë™ì„± ìì‚°ì˜ ë¹„ì¤‘ì„ ì¤„ì´ê³  ë°©ì–´ì ìœ¼ë¡œ ì „í™˜í•˜ëŠ” ì‹œì ì´ë‹ˆê¹Œ, ë‹¹ì‹ ë„ ì´ë“¤ì˜ ì›€ì§ì„ì„ ì°¸ê³ í•˜ëŠ” ê²Œ ì¢‹ì„ ê²ƒ ê°™ì•„ìš”.`);
  } else {
    parts.push(`ì§€ê¸ˆì€ **ì„±ì¥ ìì‚°**ì— ìƒëŒ€ì ìœ¼ë¡œ ìœ ë¦¬í•œ í™˜ê²½ì´ì—ìš”. í•˜ì§€ë§Œ ê±°ëŒ€ ìë³¸ê°€ë“¤ì´ ì–´ë–»ê²Œ ì›€ì§ì´ëŠ”ì§€ ì£¼ì˜ ê¹Šê²Œ ì§€ì¼œë´ì•¼ í•©ë‹ˆë‹¤. ìœ ë™ì„± í™˜ê²½ì´ ë³€í•˜ë©´ ê·¸ë“¤ì˜ í¬ì§€ì…˜ë„ ë°”ë€” ìˆ˜ ìˆìœ¼ë‹ˆê¹Œìš”.`);
  }

  return parts.join("\n");
}

/**
 * ë” ìœ ì—°í•œ ë¼ë²¨ ë§¤ì¹­ (ë¶€ë¶„ ì¼ì¹˜, ëŒ€ì†Œë¬¸ì ë¬´ì‹œ)
 */
function findLabelIndex(lines: string[], searchLabel: string): number {
  // ì •í™•í•œ ë§¤ì¹­ ì‹œë„
  let idx = lines.findIndex(l => l === searchLabel);
  if (idx >= 0) return idx;

  // ëŒ€ì†Œë¬¸ì ë¬´ì‹œ ë§¤ì¹­
  const lowerSearch = searchLabel.toLowerCase();
  idx = lines.findIndex(l => l.toLowerCase() === lowerSearch);
  if (idx >= 0) return idx;

  // ë¶€ë¶„ ì¼ì¹˜ ë§¤ì¹­ (í•µì‹¬ í‚¤ì›Œë“œ ì¶”ì¶œ)
  const keywords = searchLabel.toLowerCase().split(/[,\s]+/).filter(k => k.length > 3);
  for (let i = 0; i < lines.length; i++) {
    const lineLower = lines[i].toLowerCase();
    if (keywords.every(kw => lineLower.includes(kw))) {
      return i;
    }
  }

  // íŠ¹ìˆ˜ ì¼€ì´ìŠ¤ ì²˜ë¦¬
  if (searchLabel.includes("Reverse repurchase")) {
    idx = lines.findIndex(l => 
      l.toLowerCase().includes("reverse") && 
      (l.toLowerCase().includes("repo") || l.toLowerCase().includes("repurchase"))
    );
    if (idx >= 0) return idx;
  }
  if (searchLabel.includes("Repurchase agreements") && !searchLabel.includes("Reverse")) {
    idx = lines.findIndex(l => 
      l.toLowerCase().includes("repurchase") && 
      !l.toLowerCase().includes("reverse")
    );
    if (idx >= 0) return idx;
  }
  if (searchLabel.includes("Securities held outright")) {
    idx = lines.findIndex(l => 
      l.toLowerCase().includes("securities") && 
      l.toLowerCase().includes("held") &&
      l.toLowerCase().includes("outright")
    );
    if (idx >= 0) return idx;
  }

  return -1;
}

/**
 * ê³¼ê±° ë°ì´í„° ë¡œë“œ
 */
async function loadHistoricalData(): Promise<HistoricalData[]> {
  try {
    await fs.mkdir(DATA_DIR, { recursive: true });
    const data = await fs.readFile(HISTORICAL_DATA_FILE, "utf-8");
    return JSON.parse(data);
  } catch {
    return [];
  }
}

/**
 * ê³¼ê±° ë°ì´í„° ì €ì¥
 */
async function saveHistoricalData(data: HistoricalData): Promise<void> {
  try {
    await fs.mkdir(DATA_DIR, { recursive: true });
    const historical = await loadHistoricalData();
    
    // ì¤‘ë³µ ì œê±° (ê°™ì€ ë‚ ì§œê°€ ìˆìœ¼ë©´ ì œê±°)
    const filtered = historical.filter(h => h.date !== data.date);
    
    // ìƒˆ ë°ì´í„° ì¶”ê°€
    filtered.push(data);
    
    // ë‚ ì§œìˆœ ì •ë ¬ (ìµœì‹ ì´ ë§ˆì§€ë§‰)
    filtered.sort((a, b) => a.date.localeCompare(b.date));
    
    // ìµœê·¼ 3ê°œì›”ì¹˜ë§Œ ìœ ì§€ (ì•½ 13ì£¼)
    const recent = filtered.slice(-13);
    
    await fs.writeFile(HISTORICAL_DATA_FILE, JSON.stringify(recent, null, 2), "utf-8");
  } catch (err) {
    console.error("Failed to save historical data:", err);
  }
}

/**
 * 3ê°œì›” í‰ê·  ê³„ì‚°
 */
function calculate3MonthAverage(
  historical: HistoricalData[],
  currentDate: string,
  fedLabel: string
): { avg: number; change: number } | null {
  const current = new Date(currentDate);
  const threeMonthsAgo = new Date(current);
  threeMonthsAgo.setMonth(threeMonthsAgo.getMonth() - 3);
  
  // ìµœê·¼ 3ê°œì›” ë°ì´í„° í•„í„°ë§ (ì•½ 13ì£¼)
  const recentData = historical.filter(h => {
    const dataDate = new Date(h.date);
    return dataDate >= threeMonthsAgo && dataDate < current;
  });
  
  if (recentData.length === 0) return null;
  
  // í•´ë‹¹ í•­ëª©ì˜ í‰ê·  ì”ì•¡ ê³„ì‚°
  const balances = recentData
    .map(h => {
      const card = h.cards.find(c => c.fedLabel === fedLabel);
      return card ? card.balance_musd : null;
    })
    .filter((b): b is number => b !== null);
  
  if (balances.length === 0) return null;
  
  const avg = balances.reduce((sum, b) => sum + b, 0) / balances.length;
  
  // í˜„ì¬ ì”ì•¡ (ê°€ì¥ ìµœê·¼ ë°ì´í„°)
  const latest = recentData[recentData.length - 1];
  const latestCard = latest.cards.find(c => c.fedLabel === fedLabel);
  const currentBalance = latestCard ? latestCard.balance_musd : avg;
  
  return {
    avg,
    change: currentBalance - avg
  };
}

/**
 * íŠ¹ì • ë‚ ì§œì—ì„œ ê°€ì¥ ê°€ê¹Œìš´ ëª©ìš”ì¼ ì°¾ê¸° (H.4.1ì€ ë§¤ì£¼ ëª©ìš”ì¼ ë°œí–‰)
 */
function findNearestThursday(targetDate: string): string {
  const date = new Date(targetDate);
  const dayOfWeek = date.getDay(); // 0=ì¼ìš”ì¼, 4=ëª©ìš”ì¼
  
  // ëª©ìš”ì¼ê¹Œì§€ì˜ ì¼ìˆ˜ ê³„ì‚°
  let daysToAdd = 4 - dayOfWeek;
  if (daysToAdd < 0) daysToAdd += 7; // ì´ë¯¸ ëª©ìš”ì¼ì„ ì§€ë‚¬ìœ¼ë©´ ë‹¤ìŒ ì£¼ ëª©ìš”ì¼
  if (daysToAdd === 0 && date.getHours() < 16) {
    // ì˜¤ëŠ˜ì´ ëª©ìš”ì¼ì´ê³  ì•„ì§ ë°œí–‰ ì „ì´ë©´ ì´ë²ˆ ì£¼ ëª©ìš”ì¼, ì•„ë‹ˆë©´ ë‹¤ìŒ ì£¼ ëª©ìš”ì¼
    daysToAdd = 0;
  } else if (daysToAdd === 0) {
    daysToAdd = 7; // ì´ë¯¸ ë°œí–‰ ì‹œê°„ì´ ì§€ë‚¬ìœ¼ë©´ ë‹¤ìŒ ì£¼ ëª©ìš”ì¼
  }
  
  // ê³¼ê±° ë‚ ì§œì¸ ê²½ìš° ì´ì „ ëª©ìš”ì¼ ì°¾ê¸°
  if (daysToAdd > 3) {
    daysToAdd -= 7; // ì´ì „ ì£¼ ëª©ìš”ì¼ë¡œ
  }
  
  const thursday = new Date(date);
  thursday.setDate(date.getDate() + daysToAdd);
  
  const year = thursday.getFullYear();
  const month = String(thursday.getMonth() + 1).padStart(2, '0');
  const day = String(thursday.getDate()).padStart(2, '0');
  
  return `${year}-${month}-${day}`;
}

/**
 * FED H.4.1 ë°œí‘œ ë‚ ì§œ ëª©ë¡ ìƒì„± (Feed ìš°ì„ , HTML ìŠ¤í¬ë˜í•‘ fallback)
 */
async function getFedReleaseDatesFromFeed(): Promise<string[]> {
  try {
    const feedUrl = "https://www.federalreserve.gov/feeds/h41.html";
    const response = await fetch(feedUrl, {
      headers: { "User-Agent": "h41-dashboard/1.0 (+cursor)" },
      cache: "no-store" // ìºì‹œ ë°©ì§€
    });
    
    if (!response.ok) {
      console.warn(`[H.4.1] Failed to fetch feed from ${feedUrl}`);
      return [];
    }
    
    const feedText = await response.text();
    const dates: string[] = [];
    const dateSet = new Set<string>();
    
    // RSS/Atom Feedì—ì„œ /releases/h41/YYYYMMDD/ íŒ¨í„´ìœ¼ë¡œ ë‚ ì§œ ì¶”ì¶œ
    // ì—¬ëŸ¬ íŒ¨í„´ ì‹œë„: /releases/h41/YYYYMMDD/, /h41/YYYYMMDD/, h41/YYYYMMDD
    const patterns = [
      /\/releases\/h41\/(\d{8})\//g,
      /\/h41\/(\d{8})\//g,
      /h41\/(\d{8})\//g,
      /h41\/(\d{8})/g,
    ];
    
    for (const pattern of patterns) {
      let match;
      while ((match = pattern.exec(feedText)) !== null) {
        const dateStr = match[1];
        const year = dateStr.substring(0, 4);
        const month = dateStr.substring(4, 6);
        const day = dateStr.substring(6, 8);
        const isoDate = `${year}-${month}-${day}`;
        
        // ìœ íš¨í•œ ë‚ ì§œì¸ì§€ í™•ì¸ (í˜„ì¬ ì—°ë„ - 2ë…„ ì´ìƒë§Œ í—ˆìš©, ì•„ì¹´ì´ë¸Œ ì œì™¸)
        const yearNum = parseInt(year);
        const currentYear = new Date().getFullYear();
        const minYear = currentYear - 2; // 2024 ì´ìƒë§Œ í—ˆìš© (2026 ê¸°ì¤€)
        if (yearNum >= minYear && yearNum <= 2100 && !dateSet.has(isoDate)) {
          dates.push(isoDate);
          dateSet.add(isoDate);
        }
      }
    }
    
  // ISO í˜•ì‹ìœ¼ë¡œ ì •ê·œí™” ë° ì •ë ¬
  const normalizedDates = dates.filter(date => /^\d{4}-\d{2}-\d{2}$/.test(date));
  
  // í˜„ì¬ ì—°ë„ - 2ë…„ ì´ìƒë§Œ í•„í„°ë§ (ì•„ì¹´ì´ë¸Œ ì œì™¸)
  const currentYear = new Date().getFullYear();
  const minYear = currentYear - 2; // 2024 ì´ìƒë§Œ í—ˆìš© (2026 ê¸°ì¤€)
  const filteredDates = normalizedDates.filter(date => {
    const year = new Date(date).getFullYear();
    return year >= minYear;
  });
  
  filteredDates.sort((a, b) => {
    const dateA = new Date(a).getTime();
    const dateB = new Date(b).getTime();
    return dateB - dateA; // ìµœì‹ ìˆœ ë‚´ë¦¼ì°¨ìˆœ
  });
  
  console.log(`[H.4.1] Feed extracted ${normalizedDates.length} dates (filtered to ${filteredDates.length} recent dates, minYear: ${minYear})`);
  console.log(`[H.4.1] Top 20 feed dates:`, filteredDates.slice(0, 20));
  
  // ì—°ë„ ê²½ê³„ ë‚ ì§œ í™•ì¸
  const criticalDates = ['2026-01-02', '2025-12-29', '2026-01-08', '2025-12-18'];
  const foundCriticalDates = criticalDates.filter(d => filteredDates.includes(d));
  console.log(`[H.4.1] Feed critical dates check - Found: [${foundCriticalDates.join(', ')}], Missing: [${criticalDates.filter(d => !filteredDates.includes(d)).join(', ')}]`);
  
  return filteredDates;
  } catch (e) {
    console.warn(`[H.4.1] Error fetching feed:`, e instanceof Error ? e.message : String(e));
    return [];
  }
}

/**
 * FED H.4.1 ë°œí‘œ ë‚ ì§œ ëª©ë¡ ìƒì„± (HTML ìŠ¤í¬ë˜í•‘ - Fallback)
 */
async function getFedReleaseDatesFromHTML(): Promise<string[]> {
  try {
    const url = "https://www.federalreserve.gov/releases/h41/";
    const response = await fetch(url, { 
      headers: { "User-Agent": "h41-dashboard/1.0 (+cursor)" },
      cache: "no-store" // ìºì‹œ ë°©ì§€
    });
    
    if (!response.ok) {
      console.warn(`[H.4.1] Failed to fetch release dates from HTML`);
      return [];
    }
    
    const html = await response.text();
    const $ = cheerio.load(html);
    
    const dates: string[] = [];
    const dateSet = new Set<string>(); // ì¤‘ë³µ ë°©ì§€ìš©
    
    // íŒ¨í„´ 1: í…Œì´ë¸” ë‚´ ë§í¬ì—ì„œ ë‚ ì§œ ì¶”ì¶œ (ê¸°ì¡´ ë°©ì‹)
    $('table.release-date-table td a, table td a[href*="/h41/"]').each((_idx, element) => {
      const href = $(element).attr('href');
      const dateText = $(element).text().trim();
      extractDateFromHref(href, dates, dateSet);
      if (!dateSet.has(dates[dates.length - 1])) {
        extractDateFromText(dateText, dates, dateSet);
      }
    });
    
    // íŒ¨í„´ 2: í˜ì´ì§€ ì „ì²´ì—ì„œ /h41/YYYYMMDD/ íŒ¨í„´ ê²€ìƒ‰ (ë” í¬ê´„ì )
    const allLinks = $('a[href*="/h41/"]');
    if (allLinks.length > 0) {
      allLinks.each((_idx, element) => {
        const href = $(element).attr('href');
        extractDateFromHref(href, dates, dateSet);
      });
    }
    
    // íŒ¨í„´ 3: HTML ì „ì²´ì—ì„œ ì •ê·œì‹ìœ¼ë¡œ ë‚ ì§œ íŒ¨í„´ ì§ì ‘ ê²€ìƒ‰ (ìµœí›„ì˜ ìˆ˜ë‹¨)
    const hrefMatches = html.match(/\/h41\/(\d{8})\//g);
    if (hrefMatches) {
      hrefMatches.forEach(match => {
        const dateMatch = match.match(/(\d{8})/);
        if (dateMatch) {
          const dateStr = dateMatch[1];
          const year = dateStr.substring(0, 4);
          const month = dateStr.substring(4, 6);
          const day = dateStr.substring(6, 8);
          const isoDate = `${year}-${month}-${day}`;
          if (!dateSet.has(isoDate)) {
            dates.push(isoDate);
            dateSet.add(isoDate);
          }
        }
      });
    }
    
    // ë‚ ì§œ ì¶”ì¶œ í—¬í¼ í•¨ìˆ˜ë“¤
    function extractDateFromHref(href: string | undefined, datesArray: string[], dateSet: Set<string>) {
      if (!href) return;
      
      // ì—¬ëŸ¬ íŒ¨í„´ ì‹œë„: /h41/YYYYMMDD/, /releases/h41/YYYYMMDD/, h41/YYYYMMDD
      const patterns = [
        /\/h41\/(\d{8})\//,
        /\/releases\/h41\/(\d{8})\//,
        /h41\/(\d{8})\//,
        /h41\/(\d{8})/,
      ];
      
      for (const pattern of patterns) {
        const match = href.match(pattern);
        if (match) {
          const dateStr = match[1];
          const year = dateStr.substring(0, 4);
          const month = dateStr.substring(4, 6);
          const day = dateStr.substring(6, 8);
          const isoDate = `${year}-${month}-${day}`;
          
          // ìœ íš¨í•œ ë‚ ì§œì¸ì§€ í™•ì¸ (í˜„ì¬ ì—°ë„ - 2ë…„ ì´ìƒë§Œ í—ˆìš©, ì•„ì¹´ì´ë¸Œ ì œì™¸)
          const yearNum = parseInt(year);
          const currentYear = new Date().getFullYear();
          const minYear = currentYear - 2; // 2024 ì´ìƒë§Œ í—ˆìš© (2026 ê¸°ì¤€)
          if (yearNum >= minYear && yearNum <= 2100 && !dateSet.has(isoDate)) {
            datesArray.push(isoDate);
            dateSet.add(isoDate);
            return;
          }
        }
      }
    }
    
    function extractDateFromText(dateText: string, datesArray: string[], dateSet: Set<string>) {
      if (!dateText) return;
      
      try {
        const date = new Date(dateText);
        if (!isNaN(date.getTime())) {
          const year = date.getFullYear();
          const month = String(date.getMonth() + 1).padStart(2, '0');
          const day = String(date.getDate()).padStart(2, '0');
          const isoDate = `${year}-${month}-${day}`;
          
          // ìœ íš¨í•œ ë‚ ì§œì¸ì§€ í™•ì¸ (í˜„ì¬ ì—°ë„ - 2ë…„ ì´ìƒë§Œ í—ˆìš©, ì•„ì¹´ì´ë¸Œ ì œì™¸)
          const currentYear = new Date().getFullYear();
          const minYear = currentYear - 2; // 2024 ì´ìƒë§Œ í—ˆìš© (2026 ê¸°ì¤€)
          if (year >= minYear && year <= 2100 && !dateSet.has(isoDate)) {
            datesArray.push(isoDate);
            dateSet.add(isoDate);
          }
        }
      } catch (e) {
        // ë‚ ì§œ íŒŒì‹± ì‹¤íŒ¨ ì‹œ ë¬´ì‹œ
      }
    }
    
    // ì¤‘ë³µ ì œê±° (ì´ë¯¸ dateSetìœ¼ë¡œ ì²˜ë¦¬í–ˆì§€ë§Œ ì´ì¤‘ í™•ì¸)
    const uniqueDatesRaw = Array.from(new Set(dates));
    
    // ISO í˜•ì‹ìœ¼ë¡œ ì •ê·œí™” (ìœ íš¨í•œ ISO í˜•ì‹ë§Œ ìœ ì§€)
    const normalizedDates = uniqueDatesRaw.filter(date => /^\d{4}-\d{2}-\d{2}$/.test(date));
    
    // í˜„ì¬ ì—°ë„ - 2ë…„ ì´ìƒë§Œ í•„í„°ë§ (ì•„ì¹´ì´ë¸Œ ì œì™¸)
    const currentYear = new Date().getFullYear();
    const minYear = currentYear - 2; // 2024 ì´ìƒë§Œ í—ˆìš© (2026 ê¸°ì¤€)
    const filteredDates = normalizedDates.filter(date => {
      const year = new Date(date).getFullYear();
      return year >= minYear;
    });
    
    // ISO í˜•ì‹ ë‚ ì§œë¥¼ Date ê°ì²´ì˜ getTime()ìœ¼ë¡œ ì •ë ¬ (í‘œì‹œìš© ë¬¸ìì—´ì´ ì•„ë‹Œ ìˆ«ìë¡œ ì •ë ¬)
    filteredDates.sort((a, b) => {
      const dateA = new Date(a).getTime();
      const dateB = new Date(b).getTime();
      // ìµœì‹  ë‚ ì§œê°€ ìœ„ë¡œ ì˜¤ë„ë¡ ë‚´ë¦¼ì°¨ìˆœ ì •ë ¬
      return dateB - dateA;
    });
    
    const uniqueDates = filteredDates;
    
    // ë””ë²„ê¹…: ì›ì²œ ìŠ¤í¬ë˜í•‘ ê²°ê³¼ ë¡œê¹…
    console.log(`[H.4.1] Scraped ${normalizedDates.length} dates from HTML (filtered to ${uniqueDates.length} recent dates, minYear: ${minYear})`);
    console.log(`[H.4.1] Top 15 scraped dates (for verification):`, uniqueDates.slice(0, 15));
    
    // ì—°ë„ ê²½ê³„ ë‚ ì§œ í™•ì¸ (2026-01-02, 2025-12-29 ë“±)
    const criticalDates = ['2026-01-02', '2025-12-29', '2026-01-08', '2025-12-18'];
    const foundCriticalDates = criticalDates.filter(d => uniqueDates.includes(d));
    console.log(`[H.4.1] Critical dates check - Found: [${foundCriticalDates.join(', ')}], Missing: [${criticalDates.filter(d => !uniqueDates.includes(d)).join(', ')}]`);
    
    // ë‚ ì§œê°€ ì—†ê±°ë‚˜ ë„ˆë¬´ ì ìœ¼ë©´ ë¹ˆ ë°°ì—´ ë°˜í™˜ (ìµœìƒìœ„ì—ì„œ fallback ì²˜ë¦¬)
    if (uniqueDates.length === 0) {
      console.warn(`[H.4.1] No recent dates found from HTML scraping (minYear: ${minYear})`);
      return [];
    }
    
    // ìµœëŒ€ 52ì£¼ì¹˜ë§Œ ë°˜í™˜
    return uniqueDates.slice(0, 52);
  } catch (e) {
    console.warn(`[H.4.1] Error fetching release dates from HTML:`, e instanceof Error ? e.message : String(e));
    return [];
  }
}

/**
 * FED H.4.1 ë°œí‘œ ë‚ ì§œ ëª©ë¡ ìƒì„± (current/ ê¸°ì¤€ì  ì—­íƒìƒ‰ ìš°ì„ , Feed/HTML ìµœí›„ fallback)
 */
export async function getFedReleaseDates(): Promise<string[]> {
  // 1ì°¨: current/ í˜ì´ì§€ ê¸°ì¤€ì  ì—­íƒìƒ‰ ë°©ì‹ìœ¼ë¡œ ìµœê·¼ ë°œí‘œì¼ ìˆ˜ì§‘ (ìš°ì„ )
  try {
    // discoverRecentReleaseDatesê°€ ë‚´ë¶€ì—ì„œ getAnchorReleaseDate()ë¥¼ í˜¸ì¶œí•˜ì—¬ current/ í˜ì´ì§€ì—ì„œ ê¸°ì¤€ì  íŒŒì‹±
    const discoveredDates = await discoverRecentReleaseDates({
      targetCount: 40,
      lookbackDays: 120
    });
    
    if (discoveredDates.length >= 15) {
      console.log(`[H.4.1] Discovery method (current/ anchor) found ${discoveredDates.length} dates`);
      
      // ì—°ë„ ê²½ê³„ ë‚ ì§œ í™•ì¸
      const criticalDates = ['2026-01-02', '2025-12-29', '2026-01-08', '2025-12-18'];
      const foundCriticalDates = criticalDates.filter(d => discoveredDates.includes(d));
      console.log(`[H.4.1] Discovery critical dates check - Found: [${foundCriticalDates.join(', ')}], Missing: [${criticalDates.filter(d => !discoveredDates.includes(d)).join(', ')}]`);
      
      // ìµœëŒ€ 52ì£¼ì¹˜ë§Œ ë°˜í™˜
      return discoveredDates.slice(0, 52);
    } else {
      console.warn(`[H.4.1] Discovery method found insufficient dates (${discoveredDates.length}), falling back to Feed/HTML`);
    }
  } catch (e) {
    const errorMsg = e instanceof Error ? e.message : String(e);
    console.warn(`[H.4.1] Discovery method (current/ anchor) failed: ${errorMsg}`);
    // ì—­íƒìƒ‰ ì‹¤íŒ¨ ì‹œ fallback ê³„ì† ì§„í–‰
  }
  
  // 2ì°¨: Feedì—ì„œ ë‚ ì§œ ì¶”ì¶œ (fallback)
  const feedDates = await getFedReleaseDatesFromFeed();
  
  // Feedì—ì„œ ì¶©ë¶„í•œ ë‚ ì§œë¥¼ ì–»ì—ˆëŠ”ì§€ í™•ì¸ (ìµœì†Œ 10ê°œ ì´ìƒ)
  if (feedDates.length >= 10) {
    console.log(`[H.4.1] Using feed dates (${feedDates.length} dates)`);
    
    // ì—°ë„ ê²½ê³„ ê²€ì¦: 12ì›”/1ì›”ì—ì„œ 2ì£¼ ë‚´ ë°ì´í„°ê°€ ìµœì†Œ 3ê°œ ì´ìƒ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸
    const now = new Date();
    const currentYear = now.getFullYear();
    const yearBoundaryDates = feedDates.filter(date => {
      const dateObj = new Date(date);
      const month = dateObj.getMonth() + 1; // 1-12
      const year = dateObj.getFullYear();
      // 12ì›” ë˜ëŠ” 1ì›”ì´ê³ , í˜„ì¬ ì—°ë„ ê¸°ì¤€ 2ì£¼ ë‚´
      return (month === 12 || month === 1) && 
             (year === currentYear || year === currentYear - 1 || year === currentYear + 1);
    });
    
    if (yearBoundaryDates.length >= 3) {
      console.log(`[H.4.1] Year boundary validation passed (${yearBoundaryDates.length} dates found)`);
      return feedDates;
    } else {
      console.warn(`[H.4.1] Year boundary validation failed (${yearBoundaryDates.length} dates found), merging HTML dates`);
    }
  } else {
    console.warn(`[H.4.1] Feed returned insufficient dates (${feedDates.length}), trying HTML fallback`);
  }
  
  // 2ì°¨: HTML ìŠ¤í¬ë˜í•‘ (fallback)
  const htmlDates = await getFedReleaseDatesFromHTML();
  
  // Feedì™€ HTML ë‚ ì§œ ë³‘í•© (Setìœ¼ë¡œ ì¤‘ë³µ ì œê±°)
  const dateSet = new Set<string>();
  feedDates.forEach(date => dateSet.add(date));
  htmlDates.forEach(date => dateSet.add(date));
  
  const mergedDates = Array.from(dateSet);
  
  // ISO í˜•ì‹ìœ¼ë¡œ ì •ê·œí™” ë° ì •ë ¬
  const normalizedDates = mergedDates.filter(date => /^\d{4}-\d{2}-\d{2}$/.test(date));
  
  // í˜„ì¬ ì—°ë„ - 2ë…„ ì´ìƒë§Œ í•„í„°ë§ (ì•„ì¹´ì´ë¸Œ ì œì™¸)
  const currentYear = new Date().getFullYear();
  const minYear = currentYear - 2; // 2024 ì´ìƒë§Œ í—ˆìš© (2026 ê¸°ì¤€)
  const filteredDates = normalizedDates.filter(date => {
    const year = new Date(date).getFullYear();
    return year >= minYear;
  });
  
  filteredDates.sort((a, b) => {
    const dateA = new Date(a).getTime();
    const dateB = new Date(b).getTime();
    return dateB - dateA; // ìµœì‹ ìˆœ ë‚´ë¦¼ì°¨ìˆœ
  });
  
  console.log(`[H.4.1] Merged dates: ${normalizedDates.length} (filtered to ${filteredDates.length} recent dates, minYear: ${minYear}) (Feed: ${feedDates.length}, HTML: ${htmlDates.length})`);
  console.log(`[H.4.1] Top 20 merged dates:`, filteredDates.slice(0, 20));
  
  // ì—°ë„ ê²½ê³„ ë‚ ì§œ ìµœì¢… í™•ì¸
  const criticalDates = ['2026-01-02', '2025-12-29', '2026-01-08', '2025-12-18'];
  const foundCriticalDates = criticalDates.filter(d => filteredDates.includes(d));
  console.log(`[H.4.1] Final critical dates check - Found: [${foundCriticalDates.join(', ')}], Missing: [${criticalDates.filter(d => !filteredDates.includes(d)).join(', ')}]`);
  
  // ìµœì¢… ê²°ê³¼ê°€ ë¹„ì–´ìˆìœ¼ë©´ fallback ì‚¬ìš© (fallbackë„ ìµœì‹  ë‚ ì§œë§Œ ë°˜í™˜)
  if (filteredDates.length === 0) {
    console.warn(`[H.4.1] No recent dates found from feed or HTML (minYear: ${minYear}), falling back to calculated dates`);
    const fallbackDates = getFedReleaseDatesFallback();
    if (fallbackDates.length === 0) {
      console.error(`[H.4.1] Fallback also returned no dates. This indicates no recent H.4.1 data is available.`);
      return []; // ë¹ˆ ë°°ì—´ ë°˜í™˜ (ê³¼ê±° ì•„ì¹´ì´ë¸Œë¡œ fallbackí•˜ì§€ ì•ŠìŒ)
    }
    return fallbackDates;
  }
  
  // ìµœëŒ€ 52ì£¼ì¹˜ë§Œ ë°˜í™˜
  return filteredDates.slice(0, 52);
}

/**
 * FED H.4.1 ë°œí‘œ ë‚ ì§œ ëª©ë¡ ìƒì„± (ê³„ì‚°ëœ ëª©ìš”ì¼ - Fallback)
 */
function getFedReleaseDatesFallback(): string[] {
  const dates: string[] = [];
  const now = new Date();
  const currentYear = now.getFullYear();
  const minYear = currentYear - 2; // í˜„ì¬ ì—°ë„ - 2ë…„ ì´ìƒë§Œ í—ˆìš© (ì•„ì¹´ì´ë¸Œ ì œì™¸)
  
  // ì˜¤ëŠ˜ì´ ëª©ìš”ì¼ì´ê³  ì˜¤í›„ 4ì‹œ 30ë¶„ ì´í›„ë©´ ì´ë²ˆ ì£¼ ëª©ìš”ì¼ í¬í•¨, ì•„ë‹ˆë©´ ì œì™¸
  const today = new Date();
  const isThursday = today.getDay() === 4;
  const isAfterRelease = today.getHours() >= 16 || (today.getHours() === 16 && today.getMinutes() >= 30);
  
  // ì‹œì‘ ë‚ ì§œ: ì˜¤ëŠ˜ì´ ëª©ìš”ì¼ì´ê³  ë°œí–‰ ì‹œê°„ ì´í›„ë©´ ì˜¤ëŠ˜, ì•„ë‹ˆë©´ ê°€ì¥ ìµœê·¼ ê³¼ê±° ëª©ìš”ì¼
  let startDate = new Date(now);
  if (!isThursday || !isAfterRelease) {
    // ê°€ì¥ ìµœê·¼ ê³¼ê±° ëª©ìš”ì¼ ì°¾ê¸°
    const dayOfWeek = now.getDay();
    const daysToSubtract = dayOfWeek <= 4 ? (dayOfWeek + 3) : (dayOfWeek - 4);
    startDate.setDate(now.getDate() - daysToSubtract);
  }
  
  // ìµœê·¼ 52ì£¼ ëª©ìš”ì¼ ìƒì„± (í˜„ì¬ ì—°ë„ - 2ë…„ ì´ìƒë§Œ)
  for (let i = 0; i < 52; i++) {
    const thursday = new Date(startDate);
    thursday.setDate(startDate.getDate() - (i * 7));
    
    const year = thursday.getFullYear();
    
    // í˜„ì¬ ì—°ë„ - 2ë…„ ë¯¸ë§Œì´ë©´ ì¤‘ë‹¨ (ì•„ì¹´ì´ë¸Œ ì œì™¸)
    if (year < minYear) {
      break;
    }
    
    const month = String(thursday.getMonth() + 1).padStart(2, '0');
    const day = String(thursday.getDate()).padStart(2, '0');
    
    dates.push(`${year}-${month}-${day}`);
  }
  
  return dates;
}

/**
 * íŠ¹ì • ë‚ ì§œì˜ H.4.1 ë¦¬í¬íŠ¸ ê°€ì ¸ì˜¤ê¸°
 * @param targetDate ì„ íƒì  ë‚ ì§œ (YYYY-MM-DD í˜•ì‹), ì—†ìœ¼ë©´ ìµœì‹  ë°ì´í„°
 * @param availableDates ì‚¬ìš© ê°€ëŠ¥í•œ ë‚ ì§œ ëª©ë¡ (ê°€ì¥ ê°€ê¹Œìš´ ë‚ ì§œ ì°¾ê¸°ìš©)
 * ì„ íƒí•œ ë‚ ì§œì—ì„œ ê°€ì¥ ê°€ê¹Œìš´ ëª©ìš”ì¼ì˜ ë°ì´í„°ë¥¼ ê°€ì ¸ì˜µë‹ˆë‹¤.
 * í•´ë‹¹ ë‚ ì§œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìœ¼ë©´ availableDatesì—ì„œ ê°€ì¥ ê°€ê¹Œìš´ ë‚ ì§œë¥¼ ì‹œë„í•©ë‹ˆë‹¤.
 */
export async function fetchH41Report(targetDate?: string, availableDates?: string[]): Promise<H41Report> {
  let url = SOURCE_URL;
  let thursdayDate: string | undefined;
  
  // ê³¼ê±° ë‚ ì§œê°€ ì§€ì •ëœ ê²½ìš° ê°€ì¥ ê°€ê¹Œìš´ ëª©ìš”ì¼ ì°¾ê¸°
  if (targetDate) {
    try {
      // targetDateê°€ ì´ë¯¸ ëª©ìš”ì¼ì¸ì§€ í™•ì¸ (getFedReleaseDatesì—ì„œ ì˜¨ ê²½ìš°)
      const dateObj = new Date(targetDate);
      const dayOfWeek = dateObj.getDay();
      
      // ì•„ì¹´ì´ë¸Œ ë‚ ì§œ ê²€ì¦: 2023-01-01 ì´ì „ ë‚ ì§œëŠ” íŒŒì‹± ê¸ˆì§€
      const archiveMinDate = new Date('2023-01-01');
      if (dateObj < archiveMinDate) {
        throw new Error(`Archive H.4.1 page detected (date: ${targetDate}) â€“ parsing skipped. Only recent data (2023-01-01 or later) is supported.`);
      }
      
      if (dayOfWeek === 4) {
        // ì´ë¯¸ ëª©ìš”ì¼ì´ë©´ ê·¸ëŒ€ë¡œ ì‚¬ìš©
        thursdayDate = targetDate;
      } else {
        // ëª©ìš”ì¼ì´ ì•„ë‹ˆë©´ ê°€ì¥ ê°€ê¹Œìš´ ëª©ìš”ì¼ ì°¾ê¸°
        thursdayDate = findNearestThursday(targetDate);
      }
      
      // ëª©ìš”ì¼ ë‚ ì§œë„ ì•„ì¹´ì´ë¸Œ ê²€ì¦
      const thursdayDateObj = new Date(thursdayDate);
      if (thursdayDateObj < archiveMinDate) {
        throw new Error(`Archive H.4.1 page detected (Thursday date: ${thursdayDate}) â€“ parsing skipped. Only recent data (2023-01-01 or later) is supported.`);
      }
      
      const date = new Date(thursdayDate);
      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const day = String(date.getDate()).padStart(2, '0');
      
      // H.4.1 ì•„ì¹´ì´ë¸Œ URL í˜•ì‹ ì‹œë„:
      // 1. https://www.federalreserve.gov/releases/h41/YYYYMMDD/ (ë””ë ‰í† ë¦¬)
      // 2. https://www.federalreserve.gov/releases/h41/YYYYMMDD/default.htm (HTML íŒŒì¼)
      // 3. https://www.federalreserve.gov/releases/h41/YYYYMMDD/h41.txt (í…ìŠ¤íŠ¸ íŒŒì¼)
      const archiveUrl = `${ARCHIVE_BASE_URL}${year}${month}${day}/default.htm`;
      url = archiveUrl;
      console.log(`[H.4.1] Fetching archive for date: ${targetDate} (Thursday: ${thursdayDate}), URL: ${archiveUrl}`);
    } catch (e) {
      console.error("Invalid date format or archive date detected, using current:", e);
      // ì•„ì¹´ì´ë¸Œ ë‚ ì§œì¸ ê²½ìš° ì—ëŸ¬ë¥¼ ë‹¤ì‹œ throwí•˜ì—¬ í˜¸ì¶œìê°€ ì²˜ë¦¬í•  ìˆ˜ ìˆë„ë¡ í•¨
      if (e instanceof Error && e.message.includes('Archive H.4.1 page detected')) {
        throw e;
      }
    }
  }
  
  const res = await fetch(url, {
    headers: { "user-agent": "h41-dashboard/1.0 (+cursor)" },
    cache: "no-store" // ìºì‹œ ë°©ì§€: í•­ìƒ ìµœì‹  ë°ì´í„° ê°€ì ¸ì˜¤ê¸°
  });
  
  if (!res.ok) {
    // ì•„ì¹´ì´ë¸Œ URLì´ ì‹¤íŒ¨í•˜ë©´ ëŒ€ì²´ URL í˜•ì‹ ì‹œë„
    if (targetDate && url !== SOURCE_URL && thursdayDate) {
      console.error(`[H.4.1] Failed to fetch archive for ${targetDate} (${url}), status: ${res.status}`);
      // ì—¬ëŸ¬ URL í˜•ì‹ ì‹œë„
      const date = new Date(thursdayDate);
      const year = date.getFullYear();
      const month = String(date.getMonth() + 1).padStart(2, '0');
      const day = String(date.getDate()).padStart(2, '0');
      
      // ëŒ€ì²´ URL í˜•ì‹ ì‹œë„: https://www.federalreserve.gov/releases/h41/YYYYMMDD/h41.txt
      const altUrl1 = `${ARCHIVE_BASE_URL}${year}${month}${day}/h41.txt`;
      console.log(`[H.4.1] Trying alternative URL format 1: ${altUrl1}`);
      const altRes1 = await fetch(altUrl1, {
        headers: { "user-agent": "h41-dashboard/1.0 (+cursor)" },
        cache: "no-store" // ìºì‹œ ë°©ì§€
      });
      
      if (altRes1.ok) {
        const html = await altRes1.text();
        if (html.length > 500) {
          const $ = cheerio.load(html);
          const report = await parseH41Report($, altUrl1);
          console.log(`[H.4.1] Successfully fetched using alternative URL format`);
          return report;
        }
      }
      
      // ë˜ ë‹¤ë¥¸ ëŒ€ì²´ URL í˜•ì‹: https://www.federalreserve.gov/releases/h41/YYYYMMDD/default.htm
      const altUrl2 = `${ARCHIVE_BASE_URL}${year}${month}${day}/default.htm`;
      console.log(`[H.4.1] Trying alternative URL format 2: ${altUrl2}`);
      const altRes2 = await fetch(altUrl2, {
        headers: { "user-agent": "h41-dashboard/1.0 (+cursor)" },
        cache: "no-store" // ìºì‹œ ë°©ì§€
      });
      
      if (altRes2.ok) {
        const html = await altRes2.text();
        if (html.length > 500) {
          const $ = cheerio.load(html);
          const report = await parseH41Report($, altUrl2);
          console.log(`[H.4.1] Successfully fetched using alternative URL format 2`);
          return report;
        }
      }
      
      throw new Error(`Failed to fetch H.4.1 archive for date ${targetDate}. Tried URLs: ${url}, ${altUrl1}, ${altUrl2}`);
    }
    throw new Error(`Failed to fetch H.4.1: ${res.status} ${res.statusText}`);
  }

  const html = await res.text();
  
  // HTMLì´ ë¹„ì–´ìˆê±°ë‚˜ ì—ëŸ¬ í˜ì´ì§€ì¸ì§€ í™•ì¸ (ì•„ì¹´ì´ë¸Œ í˜ì´ì§€ë§Œ ì²´í¬)
  if (targetDate && url !== SOURCE_URL) {
    // ì•„ì¹´ì´ë¸Œ í˜ì´ì§€ì— ëŒ€í•´ì„œë§Œ ì—„ê²©í•œ ê²€ì¦
    if (html.length < 500 || html.toLowerCase().includes("page not found") || html.toLowerCase().includes("404 error")) {
      console.error(`[H.4.1] Archive page appears to be empty or 404 for ${targetDate} (${url})`);
      // ìµœì‹  ë°ì´í„°ë¡œ í´ë°±í•˜ì§€ ì•Šê³  ì—ëŸ¬ë¥¼ ë˜ì§
      throw new Error(`Failed to fetch H.4.1 archive for date ${targetDate}. The archive page appears to be empty or not found.`);
    }
  }
  
  // ìµœì‹  ë°ì´í„°ì˜ ê²½ìš° HTMLì´ ë„ˆë¬´ ì§§ìœ¼ë©´ ì—ëŸ¬ (í•˜ì§€ë§Œ íŒŒì‹±ì„ ë¨¼ì € ì‹œë„)
  if (!targetDate && html.length < 500) {
    console.warn(`Current H.4.1 page HTML seems too short (${html.length} chars), but attempting to parse anyway`);
  }
  
  const $ = cheerio.load(html);
  let report: H41Report;
  
  try {
    report = await parseH41Report($, url);
  } catch (parseError: any) {
    // íŒŒì‹± ì‹¤íŒ¨ ì‹œ, ì•„ì¹´ì´ë¸Œ ë°ì´í„°ì¸ ê²½ìš° ì—ëŸ¬ë¥¼ ë˜ì§ (ìµœì‹  ë°ì´í„°ë¡œ í´ë°±í•˜ì§€ ì•ŠìŒ)
    if (targetDate && url !== SOURCE_URL) {
      console.error(`[H.4.1] Failed to parse archive data for ${targetDate}: ${parseError?.message}`);
      throw new Error(`Failed to parse H.4.1 archive for date ${targetDate}: ${parseError?.message || String(parseError)}`);
    }
    // ìµœì‹  ë°ì´í„° íŒŒì‹± ì‹¤íŒ¨ëŠ” ì—ëŸ¬ë¡œ ì „íŒŒ
    throw new Error(`Failed to parse H.4.1 report: ${parseError?.message || String(parseError)}`);
  }
  
  // íŒŒì‹±ëœ ë°ì´í„°ê°€ ìœ íš¨í•œì§€ í™•ì¸ (ëª¨ë“  ì¹´ë“œê°€ 0ì´ë©´ íŒŒì‹± ì‹¤íŒ¨ë¡œ ê°„ì£¼)
  const hasValidData = report.cards.some(c => c.balance_musd !== 0 || c.change_musd !== 0);
  if (!hasValidData) {
    if (targetDate && url !== SOURCE_URL) {
      console.error(`[H.4.1] Parsed data appears invalid for ${targetDate} (all zeros)`);
      throw new Error(`Parsed H.4.1 archive data appears invalid (all zeros) for date ${targetDate}`);
    }
    // ìµœì‹  ë°ì´í„°ê°€ ëª¨ë‘ 0ì´ë©´ ì—ëŸ¬
    throw new Error(`Parsed H.4.1 data appears invalid (all zeros) for ${url}`);
  }
  
  console.log(`[H.4.1] Successfully fetched report for ${targetDate || 'current'}, Week ended: ${report.asOfWeekEndedText}`);
  return report;
}

/**
 * H.4.1 ë¦¬í¬íŠ¸ íŒŒì‹± (ê³µí†µ ë¡œì§)
 */
async function parseH41Report($: cheerio.CheerioAPI, sourceUrl: string): Promise<H41Report> {
  // í…Œì´ë¸” êµ¬ì¡°ë„ í™•ì¸
  const tables = $("table");
  
  // í˜ì´ì§€ ì£¼ìš” í…ìŠ¤íŠ¸ë¥¼ "ë¼ì¸ ë‹¨ìœ„"ë¡œ ë½‘ì•„ë‚´ê¸°
  const text = $("body").text().replace(/\r/g, "");
  const lines = text
    .split("\n")
    .map(s => s.replace(/\u00a0/g, " ").trim())
    .filter(Boolean);

  const releaseDateLine = lines.find(l => l.startsWith("Release Date:")) ?? "Release Date: (unknown)";
  const releaseDateRaw = releaseDateLine.replace("Release Date:", "").trim();
  // ì›ë³¸ í˜•ì‹ ìœ ì§€ (December 18, 2025)
  const releaseDateText = releaseDateRaw;

  // "Week ended Dec 17, 2025" ê°™ì€ ë¼ì¸ì„ ì°¾ê¸°
  let asOfWeekEndedText = "(unknown)";
  
  // ì—¬ëŸ¬ íŒ¨í„´ ì‹œë„
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    // "Week ended" ë‹¤ìŒ ë¼ì¸ í™•ì¸
    if (line === "Week ended" && i + 1 < lines.length) {
      const nextLine = lines[i + 1];
      // "Change from week ended"ê°€ ì•„ë‹Œ ë‚ ì§œ í˜•ì‹ì¸ì§€ í™•ì¸
      if (!nextLine.toLowerCase().includes("change from") && 
          !nextLine.toLowerCase().includes("week ended") &&
          (nextLine.match(/[A-Z][a-z]{2,}\s+\d{1,2},\s+\d{4}/) || nextLine.match(/\d{1,2}\/\d{1,2}\/\d{4}/))) {
        asOfWeekEndedText = nextLine.trim();
        break;
      }
    }
    // "Week ended Dec 17, 2025" í˜•ì‹ (í•œ ì¤„ì— ëª¨ë‘)
    if (line.includes("Week ended") && !line.toLowerCase().includes("change from")) {
      const match = line.match(/Week ended\s+([A-Z][a-z]{2,}\s+\d{1,2},\s+\d{4})/);
      if (match) {
        asOfWeekEndedText = match[1].trim();
        break;
      }
    }
  }
  
  // ì—¬ì „íˆ ëª» ì°¾ì•˜ìœ¼ë©´ ì›ë³¸ ë°©ì‹ ì‹œë„
  if (asOfWeekEndedText === "(unknown)") {
    const weekEndedIdx = lines.findIndex(l => l === "Week ended" || (l.includes("Week ended") && !l.toLowerCase().includes("change from")));
    if (weekEndedIdx >= 0) {
      if (lines[weekEndedIdx + 1] && !lines[weekEndedIdx + 1].toLowerCase().includes("change from")) {
        asOfWeekEndedText = lines[weekEndedIdx + 1].trim();
      } else if (lines[weekEndedIdx].includes("Week ended")) {
        const extracted = lines[weekEndedIdx].replace(/Week ended/gi, "").trim();
        if (extracted && !extracted.toLowerCase().includes("change from")) {
          asOfWeekEndedText = extracted;
        }
      }
    }
  }

  // ê³¼ê±° ë°ì´í„° ë¡œë“œ
  const historical = await loadHistoricalData();
  
  // ì£¼ê°„ ì»¨í…ìŠ¤íŠ¸ ë¯¸ë¦¬ ê°€ì ¸ì˜¤ê¸°
  const weeklyContext = await getWeeklyContext();

  const cards: H41Card[] = await Promise.all(ITEM_DEFS.map(async def => {
    const idx = findLabelIndex(lines, def.fedLabel);
    if (idx < 0) {
      // ë¼ë²¨ì´ ëª» ì¡íˆë©´ 0 ì²˜ë¦¬ + ê²½ê³ ì„± í•´ì„
      return {
        key: def.key,
        title: def.title,
        fedLabel: def.fedLabel,
        balance_musd: 0,
        change_musd: 0,
        balance_okeusd: 0,
        change_okeusd: 0,
        liquidityTag: def.liquidityTag,
        concept: getConcept(def.fedLabel, def.liquidityTag),
        interpretation: `íŒŒì‹± ì‹¤íŒ¨: H.4.1 í˜ì´ì§€ êµ¬ì¡° ë³€ê²½ ê°€ëŠ¥ì„±ì´ ìˆìŠµë‹ˆë‹¤.`,
        dataDate: asOfWeekEndedText,
        qtQeSignal: "ì¤‘ë¦½"
      };
    }

    // ë¼ë²¨ ë‹¤ìŒì— ìˆ«ì ì°¾ê¸° (ì—¬ëŸ¬ ë¼ì¸ í™•ì¸)
    let balance = 0;
    let change = 0;
    
    // ë‹¤ìŒ 5ê°œ ë¼ì¸ ë‚´ì—ì„œ ìˆ«ì ì°¾ê¸°
    for (let i = 1; i <= 5; i++) {
      if (idx + i < lines.length) {
        const num = parseNumberFromText(lines[idx + i]);
        if (num !== null) {
          if (balance === 0) {
            balance = num;
          } else if (change === 0) {
            change = num;
            break;
          }
        }
      }
    }

    // ê°œë… ì„¤ëª…
    const concept = getConcept(def.fedLabel, def.liquidityTag);
    
    // í•´ì„ (ì˜ë¯¸ì™€ ì „ê°œë§Œ) - ë™ì  ì»¨í…ìŠ¤íŠ¸ í¬í•¨
    const interpretation = await interpret({ 
      liquidityTag: def.liquidityTag, 
      title: def.title,
      fedLabel: def.fedLabel, 
      change_musd: change,
      balance_musd: balance
    }, weeklyContext);
    
    // QT/QE ì‹ í˜¸
    const qtQeSignal = getQtQeSignal(def.fedLabel, change);

    const card: H41Card = {
      key: def.key,
      title: def.title,
      fedLabel: def.fedLabel,
      balance_musd: balance,
      change_musd: change,
      balance_okeusd: toOkEusd(balance),
      change_okeusd: toOkEusd(change),
      liquidityTag: def.liquidityTag,
      concept,
      interpretation,
      dataDate: asOfWeekEndedText,
      qtQeSignal
    };
    return card;
  }));

  // í˜„ì¬ ë°ì´í„°ë¥¼ ê³¼ê±° ë°ì´í„°ë¡œ ì €ì¥
  const currentDate = new Date().toISOString();
  await saveHistoricalData({
    date: currentDate,
    weekEnded: asOfWeekEndedText,
    cards: cards.map(c => ({
      fedLabel: c.fedLabel,
      balance_musd: c.balance_musd,
      change_musd: c.change_musd
    }))
  });

  // í•µì‹¬ 6ê°œ ì¹´ë“œë§Œ í•„í„°ë§
  const coreCards = cards.filter(c => CORE_FED_LABELS.includes(c.fedLabel));

  // ê²½ê³  ë ˆë²¨ ê³„ì‚°
  const warningLevel = calculateWarningLevel(cards);
  const assetGuidance = getAssetGuidance(warningLevel);
  const teamSignal = getTeamSignal(warningLevel);
  const weeklySummary = generateWeeklySummary(cards, warningLevel, teamSignal);

  return {
    releaseDateText,
    asOfWeekEndedText,
    sourceUrl: SOURCE_URL,
    cards,
    updatedAtISO: new Date().toISOString(),
    warningLevel,
    assetGuidance,
    teamSignal,
    weeklySummary,
    coreCards
  };
}

export function toKoreanDigest(r: H41Report): string {
  const levelText = ["ì•ˆì •", "ì£¼ì˜", "ê²½ê³„", "ìœ„í—˜"][r.warningLevel];
  const header = [
    `FED H.4.1 ë°ì¼ë¦¬ ìš”ì•½`,
    `- Release: ${r.releaseDateText}`,
    `- Week ended: ${r.asOfWeekEndedText}`,
    `- Source: ${r.sourceUrl}`,
    ``,
    `[ê²½ê³  ë ˆë²¨] LEVEL ${r.warningLevel} (${levelText})`,
    ``,
    `[ìì‚°êµ° ëŒ€ì‘ ê°€ì´ë“œ]`,
    r.assetGuidance,
    ``,
    `[ì²­íŒ€/ë°±íŒ€ ì‹œê·¸ë„]`,
    r.teamSignal.summary,
    `- ì²­íŒ€: ${r.teamSignal.blueTeam}`,
    `- ë°±íŒ€: ${r.teamSignal.whiteTeam}`,
    ``,
    `[í•µì‹¬ 6ê°œ ìˆ˜ì¹˜ ìš”ì•½]`
  ].join("\n");

  const body = r.coreCards
    .map(c => {
      const bal = `$${c.balance_okeusd.toFixed(1)}ì–µ`;
      const ch = fmtOk(c.change_okeusd);
      return [
        `${c.key} ${c.title}`,
        `ì”ì•¡ : ${bal}`,
        `ë³€ë™ : ${ch} (${c.change_okeusd > 0 ? "ì¦ê°€" : c.change_okeusd < 0 ? "ê°ì†Œ" : "ë³€ë™ì—†ìŒ"})`,
        `${c.interpretation}`,
        `(${c.fedLabel})`,
        ""
      ].join("\n");
    })
    .join("\n");

  const footer = [
    ``,
    `[ì£¼ê°„ ìš”ì•½ ë¦¬í¬íŠ¸]`,
    r.weeklySummary
  ].join("\n");

  return `${header}\n${body}\n${footer}`.trim();
}

